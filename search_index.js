var documenterSearchIndex = {"docs":
[{"location":"contents/","page":"Contents","title":"Contents","text":"Depth = 2","category":"page"},{"location":"fmi3_library/#library","page":"FMI3 Library Functions","title":"FMI3 Library Functions","text":"","category":"section"},{"location":"fmi3_library/#FMI2-Common-Concepts-for-Model-Exchange-and-Co-Simulation","page":"FMI3 Library Functions","title":"FMI2 Common Concepts for Model Exchange and Co-Simulation","text":"","category":"section"},{"location":"library/#Library-Functions","page":"User Level API","title":"Library Functions","text":"","category":"section"},{"location":"library/","page":"User Level API","title":"User Level API","text":"Many of the functions in this library are based on already defined functions of the FMIImport.jl library. ","category":"page"},{"location":"library/#Simulate-FMUs","page":"User Level API","title":"Simulate FMUs","text":"","category":"section"},{"location":"library/","page":"User Level API","title":"User Level API","text":"fmiSimulate\nfmiSimulateCS\nfmiSimulateME\nfmiLoad\nfmiUnload\nfmiReload","category":"page"},{"location":"library/#FMI.fmiSimulate","page":"User Level API","title":"FMI.fmiSimulate","text":"fmiSimulate(str::Union{fmi2Struct, fmi3Struct}, tspan::Union{Tuple{Float64, Float64}, Nothing}=nothing;\n                tolerance::Union{Real, Nothing} = nothing,\n                dt::Union{Real, Nothing} = nothing,\n                solver = nothing,\n                customFx = nothing,\n                recordValues::fmi2ValueReferenceFormat = nothing,\n                saveat = nothing,\n                x0::Union{AbstractArray{<:Real}, Nothing} = nothing,\n                setup::Union{Bool, Nothing} = nothing,\n                reset::Union{Bool, Nothing} = nothing, # nothing = auto\n                instantiate::Union{Bool, Nothing} = nothing,\n                freeInstance::Union{Bool, Nothing} = nothing,\n                terminate::Union{Bool, Nothing} = nothing,\n                inputValueReferences::fmi2ValueReferenceFormat = nothing,\n                inputFunction = nothing,\n                parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n                dtmax::Union{Real, Nothing} = nothing,\n                kwargs...)\n\nStarts a simulation of the FMU instance for the matching FMU type, if both types are available, CS is preferred.\n\nArguments\n\nstr::Union{fmi2StructMD, fmi3StructMD}:  Representative for an FMU in the FMI 2.0.2 Standard or FMI 3.0 Standard. Other notation:\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component} More detailed: fmi3Struct = Union{FMU3, FMU3Instance}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::FMU3: Mutable struct representing an FMU in the FMI 3.0 Standard.\nstr::FMU3Instance:  Mutable struct represents a pointer to an FMU specific data structure that contains the information needed. Also in FMI 3.0 Standard.\ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Sets the time span as a tuple or the default value from the model description is used.  \n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: Real number to set the tolerance for any OED-solver\ndt::Union{Real, Nothing} = nothing: Real number to set the step size of the OED-solver. Defaults to an automatic choice if the method is adaptive. More Info: DifferentialEquations.jl Documentation\nsolver = nothing: Any Julia-supported OED-solver  (default is Tsit5). More Info: DifferentialEquations.jl Documentation\ncustomFx = nothing: [deperecated] Ability to give a custom state derivative function ẋ=f(x,t)\nrecordValues::fmi2ValueReferenceFormat = nothing: AbstractArray of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = []: Time points to save values at (interpolated). More Info: DifferentialEquations.jl Documentation\nsaveat = nothing: Time points to save values at (interpolated). More Info: DifferentialEquations.jl Documentation\nx0::Union{AbstractArray{<:Real}, Nothing} = nothing: Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). And is therefore passed within prepareSolveFMU to fmi2Set , to set the start state.\nsetup::Bool = true: Boolean value if FMU is to be set up (default: setup=true).\nreset::Union{Bool, Nothing} = nothing: Boolean value that determines whether the FMU should be reset before simulation (default: reset:=auto).\ninstantiate::Union{Bool, Nothing} = nothing: Boolean value that decides whether to create a new instance of the specified fmu.\nfreeInstance::Union{Bool, Nothing} = nothing: Boolean value that determines whether to dispose of the given instance, unload the loaded model, and free the allocated memory and other resources allocated by the FMU interface functions.\nterminate::Union{Bool, Nothing} = nothing: Boolean value that tells the FMU that the simulation run will be aborted.\ninputValueReferences::fmi2ValueReferenceFormat = nothing: AbstractArray of input variables (strings or variableIdentifiers) to set at every simulation step\ninputFunction = nothing: Function to retrieve the values to set the inputs to\nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ndtmax::Union{Real, Nothing} = nothing: Real number for setting maximum dt for adaptive timestepping for the ODE solver. The default values are package dependent. More Info: DifferentialEquations.jl Documentation\ncallbacks = []: custom callbacks to add.\nshowProgress::Bool = true: Boolean value that determines whether a progress bar is generated for a task\nkwargs...: Further parameters of already defined functions solve(args..., kwargs...) from the library DifferentialEquations.jl\n\nReturns\n\nsuccess::Bool for CS-FMUs\nODESolution for ME-FMUs\nif keyword recordValues is set, a tuple of type (success::Bool, DiffEqCallbacks.SavedValues) for CS-FMUs\nif keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues) for ME-FMUs\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2Simulate, fmi2SimulateME, fmi2SimulateCS, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmiSimulateCS","page":"User Level API","title":"FMI.fmiSimulateCS","text":"fmiSimulateCS(str::Union{fmi2Struct,fmi3Struct}, tspan::Union{Tuple{Float64, Float64}, Nothing}=nothing;\n                    tolerance::Union{Real, Nothing} = nothing,\n                    dt::Union{Real, Nothing} = nothing,\n                    solver = nothing,\n                    customFx = nothing,\n                    recordValues::fmi2ValueReferenceFormat = nothing,\n                    saveat = [],\n                    setup::Bool = true,\n                    reset::Union{Bool, Nothing} = nothing, # nothing = auto\n                    instantiate::Union{Bool, Nothing} = nothing,\n                    freeInstance::Union{Bool, Nothing} = nothing,\n                    terminate::Union{Bool, Nothing} = nothing,\n                    inputValueReferences::fmi2ValueReferenceFormat = nothing,\n                    inputFunction = nothing,\n                    showProgress::Bool=true,\n                    parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n                    dtmax::Union{Real, Nothing} = nothing,\n                    kwargs...)\n\nStarts a simulation of the Co-Simulation FMU instance.\n\nArguments\n\nstr::Union{fmi2StructMD, fmi3StructMD}:  Representative for an FMU in the FMI 2.0.2 Standard or FMI 3.0 Standard. Other notation:\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component} More detailed: fmi3Struct = Union{FMU3, FMU3Instance}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::FMU3: Mutable struct representing an FMU in the FMI 3.0 Standard.\nstr::FMU3Instance:  Mutable struct represents a pointer to an FMU specific data structure that contains the information needed. Also in FMI 3.0 Standard.\ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Sets the time span as a tuple or the default value from the model description is used.  \n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: Real number to set the tolerance for any OED-solver\ndt::Union{Real, Nothing} = nothing: Real number to set the step size of the OED-solver. Defaults to an automatic choice if the method is adaptive. More Info: DifferentialEquations.jl Documentation\nsolver = nothing: Any Julia-supported OED-solver  (default is Tsit5). More Info: DifferentialEquations.jl Documentation\ncustomFx = nothing: [deperecated] Ability to give a custom state derivative function ẋ=f(x,t)\nrecordValues::fmi2ValueReferenceFormat = nothing: AbstractArray of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = []: Time points to save values at (interpolated). More Info: DifferentialEquations.jl Documentation\nsetup::Bool = true: Boolean, if FMU should be setup (default: setup=true)\nreset::Union{Bool, Nothing} = nothing: Boolean, if FMU should be reset before simulation (default: reset:=auto)\ninstantiate::Union{Bool, Nothing} = nothing: Boolean value that decides whether to create a new instance of the specified fmu.\nfreeInstance::Union{Bool, Nothing} = nothing: Boolean value that determines whether to dispose of the given instance, unload the loaded model, and free the allocated memory and other resources allocated by the FMU interface functions.\nterminate::Union{Bool, Nothing} = nothing: Boolean value that tells the FMU that the simulation run will be aborted.\ninputValueReferences::fmi2ValueReferenceFormat = nothing: AbstractArray of input variables (strings or variableIdentifiers) to set at every simulation step\ninputFunction = nothing: Function to retrieve the values to set the inputs to\nshowProgress::Bool = true: Boolean value that determines whether a progress bar is generated for a task\nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ndtmax::Union{Real, Nothing} = nothing: Real number for setting maximum dt for adaptive timestepping for the ODE solver. The default values are package dependent. More Info: DifferentialEquations.jl Documentation\nkwargs...: Further parameters of already defined functions solve(args..., kwargs...) from the library DifferentialEquations.jl\n\nReturns\n\nIf keyword recordValues is not set, a boolean success is returned (simulation success).\nIf keyword recordValues is set, a tuple of type (true, DiffEqCallbacks.SavedValues) or (false, nothing).\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2SimulateCS, fmi2Simulate, fmi2SimulateME, fmi2Struct, FMU2, FMU2Component, fmi3SimulateCS, fmi3Simulate, fmi3SimulateME, fmi3Struct, FMU3, FMU3Instance.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmiSimulateME","page":"User Level API","title":"FMI.fmiSimulateME","text":"fmiSimulateME(str::Union{fmi2Struct,fmi3Struct}, tspan::Union{Tuple{Float64, Float64}, Nothing}=nothing;\n                tolerance::Union{Real, Nothing} = nothing,\n                dt::Union{Real, Nothing} = nothing,\n                solver = nothing,\n                customFx = nothing,\n                recordValues::fmi2ValueReferenceFormat = nothing,\n                saveat = nothing,\n                x0::Union{AbstractArray{<:Real}, Nothing} = nothing,\n                setup::Union{Bool, Nothing} = nothing,\n                reset::Union{Bool, Nothing} = nothing,\n                instantiate::Union{Bool, Nothing} = nothing,\n                freeInstance::Union{Bool, Nothing} = nothing,\n                terminate::Union{Bool, Nothing} = nothing,\n                inputValueReferences::fmi2ValueReferenceFormat = nothing,\n                inputFunction = nothing,\n                parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n                dtmax::Union{Real, Nothing} = nothing,\n                callbacks = [],\n                showProgress::Bool = true,\n                kwargs...)\n\nSimulates a FMU instance for the given simulation time interval.\n\nArguments\n\nstr::Union{fmi2StructMD, fmi3StructMD}:  Representative for an FMU in the FMI 2.0.2 Standard or FMI 3.0 Standard. Other notation:\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component} More detailed: fmi3Struct = Union{FMU3, FMU3Instance}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::FMU3: Mutable struct representing an FMU in the FMI 3.0 Standard.\nstr::FMU3Instance:  Mutable struct represents a pointer to an FMU specific data structure that contains the information needed. Also in FMI 3.0 Standard.\ntspan::Union{Tuple{Float64, Float64}, Nothing}=nothing: Sets the time span as a tuple or the default value from the model description is used. \n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: Real number to set the tolerance for any OED-solver\ndt::Union{Real, Nothing} = nothing: Real number to set the step size of the OED-solver. Defaults to an automatic choice if the method is adaptive. More Info: DifferentialEquations.jl Documentation\nsolver = nothing: Any Julia-supported OED-solver  (default is Tsit5). More Info: DifferentialEquations.jl Documentation\ncustomFx = nothing: [deperecated] Ability to give a custom state derivative function ẋ=f(x,t)\nrecordValues::fmi2ValueReferenceFormat = nothing: AbstractArray of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues\nsaveat = nothing: Time points to save values at (interpolated). More Info: DifferentialEquations.jl Documentation\nx0::Union{AbstractArray{<:Real}, Nothing} = nothing: Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). And is therefore passed within prepareSolveFMU to fmi2Set , to set the start state.\nsetup::Bool = true: Boolean, if FMU should be setup (default: setup=true)\nreset::Union{Bool, Nothing} = nothing: Boolean, if FMU should be reset before simulation (default: reset:=auto)\ninstantiate::Union{Bool, Nothing} = nothing: Boolean value that decides whether to create a new instance of the specified fmu.\nfreeInstance::Union{Bool, Nothing} = nothing: Boolean value that determines whether to dispose of the given instance, unload the loaded model, and free the allocated memory and other resources allocated by the FMU interface functions.\nterminate::Union{Bool, Nothing} = nothing: Boolean value that tells the FMU that the simulation run will be aborted.\ninputValueReferences::fmi2ValueReferenceFormat = nothing: AbstractArray of input variables (strings or variableIdentifiers) to set at every simulation step\ninputFunction = nothing: Function to retrieve the values to set the inputs to\nparameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization\ndtmax::Union{Real, Nothing} = nothing: Real number for setting maximum dt for adaptive timestepping for the ODE solver. The default values are package dependent. More Info: DifferentialEquations.jl Documentation\ncallbacks = []: custom callbacks to add.\nshowProgress::Bool = true: Boolean value that determines whether a progress bar is generated for a task\nkwargs...: Further parameters of already defined functions solve(args..., kwargs...) from the library DifferentialEquations.jl\n\nReturns\n\nIf keyword recordValues is not set, a struct of type ODESolution.\nIf keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues).\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2SimulateME fmi2SimulateCS, fmi2Simulate, fmi2Struct, FMU2, FMU2Component.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmiLoad","page":"User Level API","title":"FMI.fmiLoad","text":"fmiLoad(pathToFMU::String; unpackPath=nothing, type=nothing)\n\nLoad FMUs independent of the FMI version, currently supporting version 2.0.X and 3.0.\n\nArguments\n\npathToFMU::String: String that contains the paths of ziped and unziped FMU folders.\n\nKeywords\n\nunpackPath=nothing: Via optional argument unpackPath, a path to unpack the FMU can be specified (default: system temporary directory).\ntype::Union{CS, ME, SE} = nothing:  Via type, a FMU type can be selected. If none of the unified type set is used, the default value type = nothing will be used.\n\nReturns\n\nReturns the instance of the FMU struct.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2Load, fmi3Load.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmiUnload","page":"User Level API","title":"FMI.fmiUnload","text":"fmiUnload(fmu::Union{FMU2, FMU3})\n\nUnloads the FMU and all its instances and frees the allocated memory.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nfmu::FMU3: Mutable struct representing a FMU and all it instantiated instances in the FMI 3.0 Standard.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2Unload, fmi3Unload.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmiReload","page":"User Level API","title":"FMI.fmiReload","text":"fmiReload(fmu::Union{FMU2, FMU3})\n\nReloads the FMU-binary. This is useful, if the FMU does not support a clean reset implementation.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nfmu::FMU3: Mutable struct representing an FMU in the FMI 3.0 Standard.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2Reload, fmi3Reload.\n\n\n\n\n\n","category":"function"},{"location":"library/#Conversion-functions","page":"User Level API","title":"Conversion functions","text":"","category":"section"},{"location":"library/","page":"User Level API","title":"User Level API","text":"fmiStringToValueReference","category":"page"},{"location":"library/#FMI.fmiStringToValueReference","page":"User Level API","title":"FMI.fmiStringToValueReference","text":"fmiStringToValueReference(dataStruct::Union{FMU2, fmi2ModelDescription, FMU3, fmmi3ModelDescription}, identifier::Union{String, AbstractArray{String}})\n\nReturns the ValueReference coresponding to the variable identifier.\n\nArguments\n\ndataStruct::Union{FMU2, fmi2ModelDescription, FMU3, fmmi3ModelDescription}: Model of the type FMU2/FMU3 or the Model Description of fmi2/fmi3. Same for Model of type FMU3 or the Model Description of fmi3\nidentifier::Union{String, AbstractArray{String}}: Variable identifier in type String or as a 1-dimensional AbstractArray containing elements of type String\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2StringToValueReference, fmi3StringToValueReference.\n\n\n\n\n\n","category":"function"},{"location":"library/#External/additional-functions","page":"User Level API","title":"External/additional functions","text":"","category":"section"},{"location":"library/","page":"User Level API","title":"User Level API","text":"fmiGetDependencies\nfmiInfo","category":"page"},{"location":"library/#FMI.fmiGetDependencies","page":"User Level API","title":"FMI.fmiGetDependencies","text":"fmiGetDependencies(fmu::FMU2)\n\nBuilding dependency matrix dim x dim for fast look-ups on variable dependencies (dim is number of states).\n\nArguments\n\nfmu::FMU2: Mutable Struct representing a FMU.\n\nRetruns\n\nfmu.dependencies::Matrix{Union{fmi2DependencyKind, Nothing}}: Returns the FMU's dependency-matrix for fast look-ups on dependencies between value references. Entries are from type fmi2DependencyKind.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2GetDependencies.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmiInfo","page":"User Level API","title":"FMI.fmiInfo","text":"fmiInfo(str::fmi2Struct)\n\nPrints FMU-specific information into the REPL.\n\nArguments\n\nstr::Union{fmi2Struct, fmi3Struct}:  Representative for an FMU in the FMI 2.0.2 Standard or FMI 3.0 Standard. Other notation:\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component} More detailed: fmi3StructMD = Union{FMU3, FMU3Instance, fmi3ModelDescription}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstr::FMU3: Mutable struct representing an FMU in the FMI 3.0 Standard.\nstr::FMU3Instance:  Mutable struct represents a pointer to an FMU specific data structure that contains the information needed. Also in FMI 3.0 Standard.\n\nReturns\n\nPrints FMU related information.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec3.0 Link: https://fmi-standard.org/\n\nSee also fmi2Info, fmi2Struct, FMU2, FMU2Component, fmi3Info, fmi3Struct, FMU3, FMU3Instance.\n\n\n\n\n\n","category":"function"},{"location":"library/#Visualize-simulation-results","page":"User Level API","title":"Visualize simulation results","text":"","category":"section"},{"location":"library/","page":"User Level API","title":"User Level API","text":"fmiPlot","category":"page"},{"location":"library/#FMI.fmiPlot","page":"User Level API","title":"FMI.fmiPlot","text":"fmiPlot(solution::FMUSolution; states::Union{Bool, Nothing}=nothing,\nvalues::Union{Bool, Nothing}=nothing,\nstateEvents::Union{Bool, Nothing}=nothing,\ntimeEvents::Union{Bool, Nothing}=nothing,\nstateIndices=nothing,\nvalueIndices=nothing,\nmaxLabelLength=64,\nplotkwargs...)\n\nPlots data from a FMU simulation run.\n\nArguments\n\nsolution::FMUSolution: Struct that contains information about the solution of a FMU simulation run.\n\nKeywords\n\nstates::Union{Bool, Nothing}: controls if states should be ploted (default = nothing)\nvalues::Union{Bool, Nothing}: controls if values should be ploted (default = nothing)\ntimeEvents::Union{Bool, Nothing}: controls if timeEvents should be ploted (default = nothing)\nstateIndices: controls the indices of ploted states, nothing for plotting all (default = nothing)\nvalueIndices: controls the indices of ploted values, nothing for plotting all (default = nothing)\nmaxLabelLength=64: controls the maximum length for legend labels (too long labels are cut from front)\n\nReturns\n\nfig: Returns a figure containing the plotted data from a ME-FMU.\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI2-specific","page":"User Level API","title":"FMI2 specific","text":"","category":"section"},{"location":"library/","page":"User Level API","title":"User Level API","text":"fmi2Simulate\nfmi2SimulateME\nfmi2SimulateCS","category":"page"},{"location":"library/#FMI.fmi2Simulate","page":"User Level API","title":"FMI.fmi2Simulate","text":"fmi2Simulate(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2Simulate() in FMI/FMI2_sim.jl\n\n\n\n\n\nfmi2Simulate(fmu::FMU2, c::Union{FMU2Component, Nothing}=nothing, tspan::Union{Tuple{Float64, Float64}, Nothing}=nothing; kwargs...)\n\nStarts a simulation of the FMU instance for the matching FMU type, if both types are available, CS is preferred.\n\nKeywords:     - recordValues: Array of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues     - setup: Boolean, if FMU should be setup (default=true)     - reset: Boolean, if FMU should be reset before simulation (default reset=setup)     - inputValues: Array of input variables (strings or variableIdentifiers) to set at every simulation step      - inputFunction: Function to retrieve the values to set the inputs to      - saveat: [ME only] Time points to save values at (interpolated)     - solver: [ME only] Any Julia-supported ODE-solver (default is default from DifferentialEquations.jl)     - customFx: [ME only, deprecated] Ability to give a custom state derivative function ẋ=f(x,t)\n\nReturns:     - success::Bool for CS-FMUs     - ODESolution for ME-FMUs     - if keyword recordValues is set, a tuple of type (success::Bool, DiffEqCallbacks.SavedValues) for CS-FMUs     - if keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues) for ME-FMUs\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmi2SimulateME","page":"User Level API","title":"FMI.fmi2SimulateME","text":"fmi2SimulateME(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SimulateME() in FMI/FMI2_sim.jl\n\n\n\n\n\nfunction fmi2SimulateME(fmu::FMU2, c::Union{FMU2Component, Nothing}=nothing, tspan::Union{Tuple{Float64, Float64}, Nothing}=nothing;\n                tolerance::Union{Real, Nothing} = nothing,\n                dt::Union{Real, Nothing} = nothing,\n                solver = nothing,\n                customFx = nothing,\n                recordValues::fmi2ValueReferenceFormat = nothing,\n                recordEventIndicators::Union{AbstractArray{<:Integer, 1}, UnitRange{<:Integer}, Nothing} = nothing,\n                recordEigenvalues::Bool=false,\n                saveat = nothing,\n                x0::Union{AbstractArray{<:Real}, Nothing} = nothing,\n                setup::Union{Bool, Nothing} = nothing,\n                reset::Union{Bool, Nothing} = nothing,\n                instantiate::Union{Bool, Nothing} = nothing,\n                freeInstance::Union{Bool, Nothing} = nothing,\n                terminate::Union{Bool, Nothing} = nothing,\n                inputValueReferences::fmi2ValueReferenceFormat = nothing,\n                inputFunction = nothing,\n                parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n                dtmax::Union{Real, Nothing} = nothing,\n                callbacksBefore = [],\n                callbacksAfter = [],\n                showProgress::Bool = true,\n                kwargs...)\n\nToDo: Update DocString\n\nSimulates a FMU instance for the given simulation time interval. State- and Time-Events are handled correctly.\n\nVia the optional keyword arguemnts inputValues and inputFunction, a custom input function f(c, u, t), f(c, t), f(u, t), f(c, u) or f(t) with c current component, u current state and t current time can be defined, that should return a array of values for fmi2SetReal(..., inputValues, inputFunction(...)).\n\nKeywords:     - solver: Any Julia-supported ODE-solver (default is the DifferentialEquations.jl default solver, currently AutoTsit5(Rosenbrock23()))     - customFx: [deprecated] Ability to give a custom state derivative function ẋ=f(x,t)     - recordValues: Array of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues     - recordEventIndicators: Array or Range of event indicators (identified by integers) to record     - recordEigenvalues: Boolean value, if eigenvalues shall be computed and recorded     - saveat: Time points to save values at (interpolated)     - setup: Boolean, if FMU should be setup (default=true)     - reset: Union{Bool, :auto}, if FMU should be reset before simulation (default reset=:auto)     - inputValueReferences: Array of input variables (strings or variableIdentifiers) to set at every simulation step      - inputFunction: Function to retrieve the values to set the inputs to      - parameters: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization      - callbacks: custom callbacks to add\n\nReturns:     - If keyword recordValues is not set, a struct of type ODESolution.     - If keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues).\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmi2SimulateCS","page":"User Level API","title":"FMI.fmi2SimulateCS","text":"fmi2SimulateCS(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SimulateCS() in FMI/FMI2_sim.jl\n\n\n\n\n\nfmi2SimulateCS(fmu::FMU2, c::Union{FMU2Component, Nothing}=nothing, tspan::Union{Tuple{Float64, Float64}, Nothing}=nothing;\n                tolerance::Union{Real, Nothing} = nothing,\n                dt::Union{Real, Nothing} = nothing,\n                recordValues::fmi2ValueReferenceFormat = nothing,\n                saveat = [],\n                setup::Union{Bool, Nothing} = nothing,\n                reset::Union{Bool, Nothing} = nothing,\n                instantiate::Union{Bool, Nothing} = nothing,\n                freeInstance::Union{Bool, Nothing} = nothing,\n                terminate::Union{Bool, Nothing} = nothing,\n                inputValueReferences::fmi2ValueReferenceFormat = nothing,\n                inputFunction = nothing,\n                showProgress::Bool=true,\n                parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing)\n\nStarts a simulation of the Co-Simulation FMU instance.\n\nVia the optional keyword arguments inputValues and inputFunction, a custom input function f(c, t) or f(t) with time t and component c can be defined, that should return a array of values for fmi2SetReal(..., inputValues, inputFunction(...)).\n\nKeywords:     - recordValues: Array of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues     - saveat: Time points to save values at (interpolated)     - setup: Boolean, if FMU should be setup (default=true)     - reset: Boolean, if FMU should be reset before simulation (default reset=setup)     - inputValueReferences: Array of input variables (strings or variableIdentifiers) to set at every simulation step      - inputFunction: Function to retrieve the values to set the inputs to      - parameters: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization  Returns:     - If keyword recordValues is not set, a boolean success is returned (simulation success).     - If keyword recordValues is set, a tuple of type (true, DiffEqCallbacks.SavedValues) or (false, nothing).\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI3-specific","page":"User Level API","title":"FMI3 specific","text":"","category":"section"},{"location":"library/","page":"User Level API","title":"User Level API","text":"fmi3Simulate\nfmi3SimulateME\nfmi3SimulateCS","category":"page"},{"location":"library/#FMI.fmi3Simulate","page":"User Level API","title":"FMI.fmi3Simulate","text":"fmi3Simulate(fmu::FMU3, args...; kwargs...)\n\nWrapper for fmi3Simulate() in FMI/FMI3_sim.jl\n\n\n\n\n\nfmi3Simulate(fmu::FMU3, c::Union{FMU3Instance, Nothing}=nothing, t_start::Union{Real, Nothing} = nothing, t_stop::Union{Real, Nothing} = nothing; kwargs...)\n\nStarts a simulation of the FMU instance for the matching FMU type, if both types are available, CS is preferred.\n\nKeywords:     - recordValues: Array of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues     - setup: Boolean, if FMU should be setup (default=true)     - reset: Boolean, if FMU should be reset before simulation (default reset=setup)     - inputValues: Array of input variables (strings or variableIdentifiers) to set at every simulation step      - inputFunction: Function to retrieve the values to set the inputs to      - saveat: [ME only] Time points to save values at (interpolated)     - solver: [ME only] Any Julia-supported ODE-solver (default is Tsit5)     - customFx: [ME only, deperecated] Ability to give a custom state derivative function ẋ=f(x,t)\n\nReturns:     - success::Bool for CS-FMUs     - ODESolution for ME-FMUs     - if keyword recordValues is set, a tuple of type (success::Bool, DiffEqCallbacks.SavedValues) for CS-FMUs     - if keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues) for ME-FMUs\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmi3SimulateME","page":"User Level API","title":"FMI.fmi3SimulateME","text":"fmi3SimulateME(fmu::FMU3, args...; kwargs...)\n\nWrapper for fmi3SimulateME() in FMI/FMI3_sim.jl\n\n\n\n\n\nfmi3SimulateME(fmu::FMU3, c::Union{FMU3Instance, Nothing}=nothing, t_start::Union{Real, Nothing} = nothing, t_stop::Union{Real, Nothing} = nothing;\n                tolerance::Union{Real, Nothing} = nothing,\n                dt::Union{Real, Nothing} = nothing,\n                solver = nothing,\n                customFx = nothing,\n                recordValues::fmi3ValueReferenceFormat = nothing,\n                saveat = nothing,\n                x0::Union{AbstractArray{<:Real}, Nothing} = nothing,\n                setup::Union{Bool, Nothing} = nothing,\n                reset::Union{Bool, Nothing} = nothing,\n                instantiate::Union{Bool, Nothing} = nothing,\n                freeInstance::Union{Bool, Nothing} = nothing,\n                terminate::Union{Bool, Nothing} = nothing,\n                inputValueReferences::fmi3ValueReferenceFormat = nothing,\n                inputFunction = nothing,\n                parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing,\n                dtmax::Union{Real, Nothing} = nothing,\n                callbacks = [],\n                showProgress::Bool = true,\n                kwargs...)\n\nSimulates a FMU instance for the given simulation time interval. State- and Time-Events are handled correctly.\n\nVia the optional keyword arguemnts inputValues and inputFunction, a custom input function f(c, u, t), f(c, t), f(u, t), f(c, u) or f(t) with c current instance, u current state and t current time can be defined, that should return a array of values for fmi3SetFloat64(..., inputValues, inputFunction(...)).\n\nKeywords:     - solver: Any Julia-supported ODE-solver (default is Tsit5)     - customFx: [deperecated] Ability to give a custom state derivative function ẋ=f(x,t)     - recordValues: Array of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues     - saveat: Time points to save values at (interpolated)     - setup: Boolean, if FMU should be setup (default=true)     - reset: Union{Bool, :auto}, if FMU should be reset before simulation (default reset=:auto)     - inputValueReferences: Array of input variables (strings or variableIdentifiers) to set at every simulation step      - inputFunction: Function to retrieve the values to set the inputs to      - parameters: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization      - callbacks: custom callbacks to add\n\nReturns:     - If keyword recordValues is not set, a struct of type ODESolution.     - If keyword recordValues is set, a tuple of type (ODESolution, DiffEqCallbacks.SavedValues).\n\n\n\n\n\n","category":"function"},{"location":"library/#FMI.fmi3SimulateCS","page":"User Level API","title":"FMI.fmi3SimulateCS","text":"fmi3SimulateCS(fmu::FMU3, args...; kwargs...)\n\nWrapper for fmi3SimulateCS() in FMI/FMI3_sim.jl\n\n\n\n\n\nfmi3SimulateCS(fmu::FMU3, c::Union{FMU3Instance, Nothing}=nothing, t_start::Union{Real, Nothing} = nothing, t_stop::Union{Real, Nothing} = nothing;\n                tolerance::Union{Real, Nothing} = nothing,\n                dt::Union{Real, Nothing} = nothing,\n                recordValues::fmi3ValueReferenceFormat = nothing,\n                saveat = [],\n                setup::Union{Bool, Nothing} = nothing,\n                reset::Union{Bool, Nothing} = nothing,\n                instantiate::Union{Bool, Nothing} = nothing,\n                freeInstance::Union{Bool, Nothing} = nothing,\n                terminate::Union{Bool, Nothing} = nothing,\n                inputValueReferences::fmi3ValueReferenceFormat = nothing,\n                inputFunction = nothing,\n                showProgress::Bool=true,\n                parameters::Union{Dict{<:Any, <:Any}, Nothing} = nothing)\n\n                Starts a simulation of the Co-Simulation FMU instance.\n\nVia the optional keyword arguments inputValues and inputFunction, a custom input function f(c, t) or f(t) with time t and instance c can be defined, that should return a array of values for fmi3SetFloat64(..., inputValues, inputFunction(...)).\n\nKeywords:     - recordValues: Array of variables (strings or variableIdentifiers) to record. Results are returned as DiffEqCallbacks.SavedValues     - saveat: Time points to save values at (interpolated)     - setup: Boolean, if FMU should be setup (default=true)     - reset: Boolean, if FMU should be reset before simulation (default reset=setup)     - inputValueReferences: Array of input variables (strings or variableIdentifiers) to set at every simulation step      - inputFunction: Function to retrieve the values to set the inputs to      - parameters: Dictionary of parameter variables (strings or variableIdentifiers) and values (Real, Integer, Boolean, String) to set parameters during initialization  Returns:     - If keyword recordValues is not set, a boolean success is returned (simulation success).     - If keyword recordValues is set, a tuple of type (true, DiffEqCallbacks.SavedValues) or (false, nothing).\n\n\n\n\n\n","category":"function"},{"location":"features/#Features","page":"Features","title":"Features","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Please note, that this guide focuses also on users, that are not familiar with FMI. The following feature explanations are written in an easy-to-read-fashion, so there might be some points that are scientifically only 95% correct. For further information on FMI and FMUs, see fmi-standard.org.","category":"page"},{"location":"features/#Execution-Configuration","page":"Features","title":"Execution Configuration","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Not all FMUs support all features they should according to the FMI-standard, so FMI.jl provides a so called execution configuration.  This configuration is also respected by FMIFlux.jl. The content of the execution configuration may change in future (together with new or deprecated features of linked libraries), but the most important core features will be kept over time. Because not all users need the full potential of this configuration tool, there are three presets given: ","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"myFMU.executionConfig = FMU2_EXECUTION_CONFIGURATION_NO_RESET is the default operation mode for FMUs. FMUs are not reset via fmi2Reset, but new instantiated for every simulation run (or training step). This is not the most efficient way, but many FMUs have problems with resetting.\nmyFMU.executionConfig = FMU2_EXECUTION_CONFIGURATION_RESET is faster for well-implemented FMUs, but needs a fully working fmi2Reset-function. So if you know you have a fully working fmi2Reset, you may be faster with that option.\nmyFMU.executionConfig = FMU2_EXECUTION_CONFIGURATION_NO_FREEING should only be the very last choice. If your FMU neither supports fmi2Reset nor a proper fmi2FreeInstance, you could use this configuration as a last way out. Keep in mind, that new FMU instances are allocated but not freed, as long as your Julia instance is running (memory leak). In general, the amount of leaked memory is small, but you need to know what you are doing, if you do thousands or ten-thousands of simulation runs with such a FMU.\nmyFMU.executionConfig = FMU2_EXECUTION_CONFIGURATION_NOTHING should be used if you want maximum control over what is done and what not. This means you need to take care of instantiating, initialization, setting up and releasing FMU instances by yourself.","category":"page"},{"location":"features/#Debugging-/-Logging","page":"Features","title":"Debugging / Logging","text":"","category":"section"},{"location":"features/#Logging-FMI-calls","page":"Features","title":"Logging FMI-calls","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"To log all FMI-calls that happen (including \"hidden\" calls e.g. if you are using fmiSimulate) you can enable debugging for FMICore.jl using ENV[\"JULIA_DEBUG\"] = \"FMICore\". This will log any fmi2xxx-call, including the given parameters and return value.","category":"page"},{"location":"features/#Printing-internal-FMU-messages","page":"Features","title":"Printing internal FMU messages","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Many FMUs support for printing debugging messages. To force message printing, you can use the keyword logginOn=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate, for example fmiInstantiate(myFMU; loggingOn=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"You can further control which message types - like OK, Warning, Discard, Error, Fatal, Pending - should be logged by using the keywords logStatus{TYPE}=true as part of fmiInstantiate or (soon) the execution configuration. By default, all are activated. If the FMU uses a variadic callback function for messages (this is not supported by Julia at this time), you may need to activate external callbacks with the keyword externalCallbacks=true either ...","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"in the call fmiInstantiate!, for example fmiInstantiate!(myFMU; loggingOn=true, externalCallbacks=true) or\nas part of the executionConfig, for example myFMU.executionConfig.loggingOn=true; myFMU.executionConfig.externalCallbacks=true","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Note, that external callbacks are currently only supported on Windows.","category":"page"},{"location":"features/#Model-variable-identification","page":"Features","title":"Model variable identification","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"FMI.jl offers multiple ways to retrieve your model variables. Any function that accepts a variable identifier can handle the following argument types:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"UInt32 or fmi2ValueReference for example 1610612742 or 0x16000001: This is the most performant way of passing a variable identifier, but you need to know the value reference (you can determine them by having a look in the modelDescription.xml).\nArray{UInt32} or Array{fmi2ValueReference} for example [1610612742, 1610612743] or [0x16000001, 0x16000002]: This is the most performant way of passing multiple variable identifiers, but you need to know the value references.\nString for example \"ball.s\": This is the most intuitive way, because you might already know the variable name from your modelling environment or model documentation.\nArray{String} for example [\"ball.s\", \"der(ball.s)\"]: This is the most intuitive way for multiple variable identifiers, because you might already know the variable names from your modelling environment or model documentation.\nSymbol for example :states: There are multiple symbol-wildcards for interesting variable groups like :all, :none, :states, :derivatives, :inputs and :outputs.\nnothing: If you don't want to record anything (same as :none)","category":"page"},{"location":"features/#Event-handling","page":"Features","title":"Event handling","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In FMI2, there are basically two types of events: state and time.  State events are triggered, as soon as one or more event indicators - scalar values that describe the \"distance\" in state space to the next state event - crossing zero.  Time events are triggered at known time points during the simulation.  If your model has state and/or time events is detected automatically by FMI.jl and the event handling happens automatically in the background.","category":"page"},{"location":"features/#Model-exchange-(ME)-and-co-simulation-(CS)","page":"Features","title":"Model exchange (ME) and co-simulation (CS)","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"There are two different model types for FMUs in FMI2: Model exchange (ME) and co-simulation (CS).  If you have a FMU and are only interested in getting it simulated, use fmiSimulate so FMI.jl will automatically pick CS if available and otherwise ME. If you want to force a specific simulation mode, you can use fmiSimulateME (for ME) or fmiSimulateCS (for CS).","category":"page"},{"location":"features/#Simulate-arbitrary-time-intervals","page":"Features","title":"Simulate arbitrary time intervals","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"You can simply simulate arbitrary time intervals by passing a startTime unequal zero to fmi2SetupExperiment.  Because many FMUs don't support startTime != 0.0 and will throw an error or warning, a time shifting feature inside FMI.jl can be used, that performs all necessary steps in the background - corresponding commands like e.g. fmi2SetTime or fmi2NewDiscreteStates act like the desired time interval is simulated. This feature is disabled by default, but can be activated in the execution configuration using myFMU.executionConfig.autoTimeShift=true while providing a startTime != 0.0.","category":"page"},{"location":"features/#Performance","page":"Features","title":"Performance","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"In- and Out-of-Place: Many commands in FMI.jl are available in in-place and out-of-place semantics. Of course, in-place-calls are faster, because they don't need to allocate new memory at every call (for the return values). So if you have an eye on performance (or must have), a good starting point is to substitute out-of-place- with in-place-calls. Typical improvements are:","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"valueArray = fmi2GetReal(args...) -> fmi2GetReal!(args..., valueArray)\nvalueArray = fmi2GetDerivatives(args...) -> fmi2GetDerivatives!(args..., valueArray)\nvalueArray = fmi2NewDiscreteStates(args...) -> fmi2NewDiscreteStates!(args..., valueArray)","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Of course, you have to use the same piece of memory (to write your return values in) for multiple calls - otherwise there will be no improvement because the number of allocations stays the same.","category":"page"},{"location":"features/","page":"Features","title":"Features","text":"Views: You can use array-views instead of array-slices as input for in-place-functions, which further reduces memory allocations.","category":"page"},{"location":"features/#AD-Ecosystem-(Differentiation-over-FMUs)","page":"Features","title":"AD-Ecosystem (Differentiation over FMUs)","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"Sensitivites over FMUs are fully integrated into FMI.jl, FMIImport.jl and FMIFlux.jl. Supported are ForwardDiff.jl together with all AD-frameworks, that use the interface of ChainRules.jl like e.g. Zygote.jl. As a result, you can use implicite solvers or you can use FMUs as part of machine learning applications.","category":"page"},{"location":"features/#Watch-your-progress","page":"Features","title":"Watch your progress","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"When simulating FMUs with FMI.jl, a progress meter is shown per default. You can control the appearance via the keyword argument showProgress for fmiSimulate, fmiSimulateME and fmiSimulateCS.  Progress meters are also available for FMIFlux.jl, but deactivated by default (during training, this can be a bit too much). When evaluating a NeuralFMU, you can use the same keyword with showProgress=true to show a progress bar during training, too. The simulation trajectory (also called the solution of your FMU's ODE system) can be plotted using fmiPlot(myFMU, solution), all axis will be labeled automatically.","category":"page"},{"location":"features/#Parallelization","page":"Features","title":"Parallelization","text":"","category":"section"},{"location":"features/","page":"Features","title":"Features","text":"A native integrated support for multi-threaded and multi-process FMU-simulation will be deployed soon. ","category":"page"},{"location":"related/#Related-Publications","page":"Related Publication","title":"Related Publications","text":"","category":"section"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Josef Kircher, Lars Mikelsons 2021 NeuralFMU: Towards Structural Integration of FMUs into Neural Networks (14th Modelica Conference, Preprint, Accepted) arXiv:2109.04351","category":"page"},{"location":"related/","page":"Related Publication","title":"Related Publication","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs (10th International Conference on Mathematical Modeling in Physical Sciences, Preprint, Accepted) arXiv:2109.04880","category":"page"},{"location":"examples/simulate/#Simulate-an-FMU-in-different-modes","page":"Simulate","title":"Simulate an FMU in different modes","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/simulate/#License","page":"Simulate","title":"License","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/simulate/#Motivation","page":"Simulate","title":"Motivation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/simulate/#Introduction-to-the-example","page":"Simulate","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In this example we want to show how fast and easy the simulation for an FMU is. For this purpose, the FMU is simulated in co-simulation mode and in model-exchange mode. After the FMU has been simulated, the simulation results are displayed in a graph. The graphs of the different modes are compared with each other. The used model is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"(Image: svg)  ","category":"page"},{"location":"examples/simulate/#Target-group","page":"Simulate","title":"Target group","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/simulate/#Other-formats","page":"Simulate","title":"Other formats","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/simulate/#Getting-started","page":"Simulate","title":"Getting started","text":"","category":"section"},{"location":"examples/simulate/#Installation-prerequisites","page":"Simulate","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/simulate/#Code-section","page":"Simulate","title":"Code section","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/simulate/#Simulation-setup","page":"Simulate","title":"Simulation setup","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"tStart = 0.0\ntStep = 0.01\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"0.0:0.01:8.0","category":"page"},{"location":"examples/simulate/#Import-FMU","page":"Simulate","title":"Import FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\n# fmiLoad(\"path/to/myFMU.fmu\"; unpackPath = \"path/to/unpacked/fmu/\")\n\nfmiInfo(myFMU)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/simulate/#Simulate-FMU","page":"Simulate","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the following, the FMU is simulated in the two different simulation modes.","category":"page"},{"location":"examples/simulate/#Simulate-as-Co-Simulation","page":"Simulate","title":"Simulate as Co-Simulation","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the next steps the recorded values are defined. The first state is the position of the mass and the second state is the velocity. In the function fmiSimulateCS() the FMU is simulated in co-simulation mode (CS) with an adaptive step size but with fixed save points tSave. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"vrs = [\"mass.s\", \"mass.v\"]\n\ndataCS = fmiSimulateCS(myFMU, (tStart, tStop); recordValues=vrs, saveat=tSave)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Model name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 0\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 0\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 0\n\tSave values: 0\n\tSteps completed: 0\nValues [801]:\n\t0.0\t(0.5, 0.0)\n\t0.01\t(0.5002235448486548, 0.042692491939260585)\n\t0.02\t(0.5008715291319449, 0.08568000508550636)\n\t0.03\t(0.5019478597521578, 0.12892136998736314)\n\t0.04\t(0.5034570452098334, 0.17232325681284336)\n\t0.05\t(0.5053993458877354, 0.2158440857658765)\n\t0.06\t(0.5077764240578201, 0.259420181133082)\n\t0.07\t(0.5105886522837868, 0.30295578207463486)\n\t0.08\t(0.5138351439717114, 0.3464184707972189)\n\t...\n\t8.0\t(1.071367253976742, -1.000814138594347e-10)\nEvents [0]:","category":"page"},{"location":"examples/simulate/#Simulate-as-Model-Exchange","page":"Simulate","title":"Simulate as Model-Exchange","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"In the function fmiSimulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size but with fixed save points tSave. In addition, the start and end time are specified. In contrast to the co-simulation, the values to be stored are not specified here, since the states and events of the FMU are always output as well. The identifiers given above just correspond to the states of the FMU.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"dataME = fmiSimulateME(myFMU, (tStart, tStop); saveat=tSave)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mUsing arrays or dicts to store parameters of different types can hurt performance.\n\u001b[33m\u001b[1m│ \u001b[22m\u001b[39mConsider using tuples instead.\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ SciMLBase ~/.julia/packages/SciMLBase/wvDeR/src/performance_warnings.jl:32\u001b[39m\n\u001b[34mSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:21\u001b[39m\n\n\n\n\n\nModel name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 1377\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 1893\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 6\n\tSave values: 0\n\tSteps completed: 131\nStates [801]:\n\t0.0\t[0.5, 0.0]\n\t0.01\t[0.5002131418270838, 0.042689450733423825]\n\t0.02\t[0.5008548874900927, 0.08570846009092127]\n\t0.03\t[0.5019281657668402, 0.12898390160770806]\n\t0.04\t[0.5034351795297135, 0.17244393632491417]\n\t0.05\t[0.5053774247131727, 0.2160182108112464]\n\t0.06\t[0.5077556991013406, 0.2596379123127993]\n\t0.07\t[0.5105701153011459, 0.3032358504004333]\n\t0.08\t[0.5138201146588774, 0.3467464532244224]\n\t...\n\t8.0\t[1.0666322778272936, -7.60398591662422e-5]\nEvents [6]:\n\tState-Event #11 @ 0.0s\n\tState-Event #11 @ 0.994s\n\tState-Event #19 @ 1.9883s\n\tState-Event #11 @ 2.9831s\n\tState-Event #19 @ 3.9789s\n\tState-Event #11 @ 4.977s","category":"page"},{"location":"examples/simulate/#Plotting-FMU","page":"Simulate","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"After the simulation is finished the results of the FMU for the co-simulation and model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"fmiPlot(dataCS)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"(Image: svg)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"fmiPlot(dataME)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"(Image: svg)","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"From both graphs it can be seen that the simulation calculates exactly the same results.","category":"page"},{"location":"examples/simulate/#Unload-FMU","page":"Simulate","title":"Unload FMU","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/simulate/#Summary","page":"Simulate","title":"Summary","text":"","category":"section"},{"location":"examples/simulate/","page":"Simulate","title":"Simulate","text":"Based on this tutorial it can be seen that simulating in the different mode is very easy, and it only takes a few commands to simulate the FMU. ","category":"page"},{"location":"faq/#FAQ","page":"FAQ","title":"FAQ","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This list some common - often numerical - errors, that can be fixed by better understanding the ODE-Problem inside your FMU.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Solving-non-linear-system-failes","page":"FAQ","title":"Solving non-linear system failes","text":"","category":"section"},{"location":"faq/#Description","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message or warning, that solving of a non-linear system failed, close to the simulation start time.","category":"page"},{"location":"faq/#Example","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Solving non-linear system 101 failed at time=3e-05.","category":"page"},{"location":"faq/#Reason","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This could be, because the first step of the integration is accepted by the solver's error estimation, but shouldn't. This is usually, if the first step is picked to large by the solver's start step size heuristics.","category":"page"},{"location":"faq/#Fix","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Try a small start value for the integration with keyword dt.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Access-denied","page":"FAQ","title":"Access denied","text":"","category":"section"},{"location":"faq/#Description-2","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message, that the binary for callback functions can't be accessed/opened.","category":"page"},{"location":"faq/#Example-2","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ERROR:\ncould not load library \"...\\src\\FMI2\\callbackFunctions\\binaries\\win64\\callbackFunctions.dll\"\nAccess denied","category":"page"},{"location":"faq/#Reason-2","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This is because your OS doesn't allow to interact with the binaries shipped with FMI.jl. ","category":"page"},{"location":"faq/#Fix-2","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This can easily be solved by fixing the binary's permission options or is automatically fixed if Julia runs with admin privileges.","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"faq/#Double-Callback-Crossing","page":"FAQ","title":"Double Callback Crossing","text":"","category":"section"},{"location":"faq/#Description-3","page":"FAQ","title":"Description","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"Error message, that solving failed because of double callback crossing.","category":"page"},{"location":"faq/#Example-3","page":"FAQ","title":"Example","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"ERROR:\nDouble callback crossing floating pointer reducer errored. Report this issue.","category":"page"},{"location":"faq/#Reason-3","page":"FAQ","title":"Reason","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This is because the event instant (time point) of an FMU event indicator can't be found precisely.","category":"page"},{"location":"faq/#Fix-3","page":"FAQ","title":"Fix","text":"","category":"section"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This can be solved by allowing for more interpolation points during searching of the zero crossing:","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"fmu.executionConfig.rootSearchInterpolationPoints = 1000 # default value is 10","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"This will have negative performance impact on systems with extreme amount of events (thousands per second).  For systems with only a few events there won't be a noticable slow down. ","category":"page"},{"location":"faq/","page":"FAQ","title":"FAQ","text":"","category":"page"},{"location":"examples/modelica_conference_2021/#Advanced-Simulation-of-an-FMU","page":"Modelica conference 2021","title":"Advanced Simulation of an FMU","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/modelica_conference_2021/#License","page":"Modelica conference 2021","title":"License","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/modelica_conference_2021/#Motivation","page":"Modelica conference 2021","title":"Motivation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/modelica_conference_2021/#Introduction-to-the-example","page":"Modelica conference 2021","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In this example we would like to show that besides the simple simulation of an FMU there is also a more advanced version of the simulation. The advantage of the more advanced variant is that there are more possibilities to intervene in the simulation to make changes. After the FMU has been simulated, the simulation results are displayed in a graph. The used model is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"(Image: svg)  ","category":"page"},{"location":"examples/modelica_conference_2021/#Target-group","page":"Modelica conference 2021","title":"Target group","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/modelica_conference_2021/#Other-formats","page":"Modelica conference 2021","title":"Other formats","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/modelica_conference_2021/#Getting-started","page":"Modelica conference 2021","title":"Getting started","text":"","category":"section"},{"location":"examples/modelica_conference_2021/#Installation-prerequisites","page":"Modelica conference 2021","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/modelica_conference_2021/#Code-section","page":"Modelica conference 2021","title":"Code section","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/modelica_conference_2021/#Simulation-setup","page":"Modelica conference 2021","title":"Simulation setup","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, the start time and end time of the simulation are set. Finally, a step size is specified to store the results of the simulation at these time steps.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"tStart = 0.0\ntStep = 0.1\ntStop = 8.0\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"0.0:0.1:8.0","category":"page"},{"location":"examples/modelica_conference_2021/#Simple-FMU-Simulation","page":"Modelica conference 2021","title":"Simple FMU Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\nfmiInfo(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the next commands the FMU is simulated, for which the start and end time and recorded variables are declared. Afterwards the simulation result is shown in a graph. In the plot for the FMU, it can be seen that the oscillation keeps decreasing due to the effect of friction. If one simulates long enough, the oscillation comes to a standstill after a certain time.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"simData = fmiSimulate(myFMU, (tStart, tStop); recordValues=[\"mass.s\"], saveat=tSave)\nfmiPlot(simData)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"(Image: svg)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/#Advanced-FMU-Simulation","page":"Modelica conference 2021","title":"Advanced FMU Simulation","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the following type of simulation a more advanced variant is presented, which allows intervening more in the simulation process. Analogous to the simple variant, an FMU model must be loaded.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"myFMU = fmiLoad(pathToFMU);","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"Next, it is necessary to create an instance of the FMU, this is achieved by the command fmiInstantiate!().  ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"instanceFMU = fmiInstantiate!(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"FMU:            SpringFrictionPendulum1D\nInstanceName:   SpringFrictionPendulum1D\nAddress:        Ptr{Nothing} @0x000000000f189210\nState:          0\nLogging:        0\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"In the following code block, start and end time for the simulation is set by the fmiSetupExperiment() command. Next, the FMU is initialized by the calls of fmiEnterInitializationMode() and fmiExitInitializationMode(). It would also be possible to set initial states for the FMU before these two commands. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmiSetupExperiment(instanceFMU, tStart, tStop)\n# set initial model states\nfmiEnterInitializationMode(instanceFMU)\n# get initial model states\nfmiExitInitializationMode(instanceFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"0x00000000","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The actual simulation loop is shown in the following block. Here a simulation step fmiDoStep() with the fixed step size tStep is executed. As indicated in the code by the comments, the input values and output values of the FMU could be changed in the simulation loop as desired, whereby the higher possibility of adjustments arises.","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"for t in tSave\n    # set model inputs \n    # ...\n    fmiDoStep(instanceFMU, tStep)\n    # get model outputs\n    # ...\nend","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"[\u001b[33mWarning\u001b[0m][][SpringFrictionPendulum1D]: : trying to compute past tStop = 8.000000, to 8.0999999999999872,  at t = 8.000000","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The instantiated FMU must be terminated and then the memory area for the instance can also be deallocated. The last step is to unload the FMU to remove all unpacked data on disc. ","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"fmiTerminate(instanceFMU)\nfmiFreeInstance!(instanceFMU)\nfmiUnload(myFMU)","category":"page"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"[\u001b[32mOK\u001b[0m][CvodeStatistics][SpringFrictionPendulum1D]: Sundials CVode Statistics\n    Stop time                                : 8.00 s\n    Simulation time                          : 0.37 s\n    Number of external steps                 : 80\n    Number of internal steps                 : 191\n    Number of non-linear iterations          : 263\n    Number of non-linear convergence failures: 0\n    Number of f function evaluations         : 291\n    Number of g function evaluations         : 339\n    Number of Jacobian-evaluations (direct)  : 7\n    Maximum integration order                : 5\n    Suggested tolerance scale factor         : 1.0\n    Grouping used                            : no","category":"page"},{"location":"examples/modelica_conference_2021/#Summary","page":"Modelica conference 2021","title":"Summary","text":"","category":"section"},{"location":"examples/modelica_conference_2021/","page":"Modelica conference 2021","title":"Modelica conference 2021","text":"The tutorial has shown that besides the usual simple variant of simulating an FMU, there is another way to make more adjustments.","category":"page"},{"location":"examples/overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"This section discusses the included examples of the FMI.jl library. If you require further information about the function calls, see the function sections of the library.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Examples are subdevided into Basics, Advanced and Publication appendices.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Basic examples:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Simulate: Showing how you can simulate a CS-FMU and a ME-FMU.\nParameterize: A short example explaining how to parameterize a FMU before simulation.\nInputs: A short example explaining how to simulate a FMU with inputs.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Advanced examples:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Parameter Optimization: An introduction on how FMU parameters can be optimized to fit a specific behaviour.\nMultiple instances: Showing the use of multiple FMU instances.\nManipulation: Showing how to redefine a linked C-library function of FMU.\nMultithreading: Shows how to use multithreading to simulate multiple FMUs.\nMultiprocessing: Shows how to use multiprocessing to simulate multiple FMUs.","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Publication appendices:","category":"page"},{"location":"examples/overview/","page":"Overview","title":"Overview","text":"Modelica conference 2021: Showing the different variants of simulating an FMU.","category":"page"},{"location":"examples/multithreading/#Multithreading","page":"Multithreading","title":"Multithreading","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multithreading/#License","page":"Multithreading","title":"License","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multithreading/#Motivation","page":"Multithreading","title":"Motivation","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multithreading/#Introduction-to-the-example","page":"Multithreading","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multithreading, check multiprocessing.ipynb for multiprocessing. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"(Image: svg)  ","category":"page"},{"location":"examples/multithreading/#Target-group","page":"Multithreading","title":"Target group","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multithreading/#Other-formats","page":"Multithreading","title":"Other formats","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multithreading/#Getting-started","page":"Multithreading","title":"Getting started","text":"","category":"section"},{"location":"examples/multithreading/#Installation-prerequisites","page":"Multithreading","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install Folds via add Folds \n6. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multithreading/#Code-section","page":"Multithreading","title":"Code section","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# imports\nusing FMI\nusing FMIZoo\nusing Folds\nusing BenchmarkTools","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"First, check the amount of available threads:","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Threads.nthreads()","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"If the number of available threads doesn't match your expections, you can increase the number of threads available to the Julia process like described here.","category":"page"},{"location":"examples/multithreading/#Simulation-setup","page":"Multithreading","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Next, the start time and end time of the simulation are set. Here we also decide the size of the batch.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"t_start = 0.0\nt_step = 0.1\nt_stop = 10.0\ntspan = (t_start, t_stop)\ntData = collect(t_start:t_step:t_stop)\n\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = Threads.nthreads()\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))\n","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{Vector{Float64}}:\n [0.5040893452710188, 0.986656211363431]","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We need to instantiate one FMU for each parallel execution, as they cannot be easily shared among different threads.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"# a single FMU to compare the performance\nrealFMU = fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\n# the FMU batch\nrealFMUBatch = [fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\") for _ in 1:batchSize]","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{FMU2}:\n Model name:        SpringPendulum1D\nType:              1","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"We define a helper function to calculate the FMU solution and combine it into an Matrix.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"function runCalcFormatted(fmu::FMU2, x0::Vector{Float64}, recordValues::Vector{String}=[\"mass.s\", \"mass.v\"])\n    data = fmiSimulateME(fmu, tspan; recordValues=recordValues, saveat=tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"runCalcFormatted (generic function with 2 methods)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"@benchmark data = runCalcFormatted(realFMU, rand(2))","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mUsing arrays or dicts to store parameters of different types can hurt performance.\n\u001b[33m\u001b[1m│ \u001b[22m\u001b[39mConsider using tuples instead.\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ SciMLBase ~/.julia/packages/SciMLBase/wvDeR/src/performance_warnings.jl:32\u001b[39m\n\n\n\n\n\nBenchmarkTools.Trial: 4 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m1.605 s\u001b[22m\u001b[39m … \u001b[35m  1.640 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m4.09% … 3.99%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m1.616 s              \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m4.05%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m1.619 s\u001b[22m\u001b[39m ± \u001b[32m14.780 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m4.05% ± 0.05%\n\n  \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[34m█\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  1.6 s\u001b[90m          Histogram: frequency by time\u001b[39m        1.64 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m467.05 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m12001288\u001b[39m.","category":"page"},{"location":"examples/multithreading/#Single-Threaded-Batch-Execution","page":"Multithreading","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(realFMU, i) for i in input_values)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Single Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 4 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m1.599 s\u001b[22m\u001b[39m … \u001b[35m  1.640 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m4.18% … 4.06%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m1.607 s              \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m4.14%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m1.613 s\u001b[22m\u001b[39m ± \u001b[32m18.586 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m4.12% ± 0.05%\n\n  \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[34m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[34m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  1.6 s\u001b[90m          Histogram: frequency by time\u001b[39m        1.64 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m467.05 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m12001291\u001b[39m.","category":"page"},{"location":"examples/multithreading/#Multithreaded-Batch-Execution","page":"Multithreading","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple threads, the library Folds can be used.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"println(\"Multi Threaded\")\n@benchmark Folds.collect(runCalcFormatted(fmu, i) for (fmu, i) in zip(realFMUBatch, input_values))","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"Multi Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 4 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m1.593 s\u001b[22m\u001b[39m … \u001b[35m 1.608 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m4.23% … 4.17%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m1.601 s             \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m4.19%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m1.601 s\u001b[22m\u001b[39m ± \u001b[32m8.031 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m4.19% ± 0.02%\n\n  \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[34m█\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  1.59 s\u001b[90m        Histogram: frequency by time\u001b[39m        1.61 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m467.05 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m12001306\u001b[39m.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than Threads.nthreads(), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n threads for the Julia process.","category":"page"},{"location":"examples/multithreading/#Unload-FMU","page":"Multithreading","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"fmiUnload(realFMU)\nfmiUnload.(realFMUBatch)","category":"page"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"1-element Vector{Nothing}:\n nothing","category":"page"},{"location":"examples/multithreading/#Summary","page":"Multithreading","title":"Summary","text":"","category":"section"},{"location":"examples/multithreading/","page":"Multithreading","title":"Multithreading","text":"In this tutorial it is shown how multi threading with Folds.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"examples/multiple_instances/#Multiple-Instances-of-an-FMU","page":"Multiple instances","title":"Multiple Instances of an FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/multiple_instances/#License","page":"Multiple instances","title":"License","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multiple_instances/#Motivation","page":"Multiple instances","title":"Motivation","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiple_instances/#Introduction-to-the-example","page":"Multiple instances","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"In this example we want to show that it is possible to create different instances of an FMU. The different instances can then be used to run independent simulations. After the FMU has been simulated, the simulation results are displayed in a graph. The used model is a one-dimensional spring pendulum without friction. The object-orientated structure of the SpringPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiple_instances/#Target-group","page":"Multiple instances","title":"Target group","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiple_instances/#Other-formats","page":"Multiple instances","title":"Other formats","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiple_instances/#Getting-started","page":"Multiple instances","title":"Getting started","text":"","category":"section"},{"location":"examples/multiple_instances/#Installation-prerequisites","page":"Multiple instances","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install Plots via add Plots ","category":"page"},{"location":"examples/multiple_instances/#Code-section","page":"Multiple instances","title":"Code section","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# imports\nusing FMI\nusing FMIZoo\nusing Plots","category":"page"},{"location":"examples/multiple_instances/#Simulation-setup","page":"Multiple instances","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Next, the start time and end time of the simulation are set. Finally, the recorded values are specified to store the results of the simulation.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"tStart = 0.0\ntStop = 8.0\n\nvrs = [\"mass.s\"]","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"1-element Vector{String}:\n \"mass.s\"","category":"page"},{"location":"examples/multiple_instances/#Import-FMU","page":"Multiple instances","title":"Import FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\nfmiInfo(myFMU)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{fc15d8c4-758b-48e6-b00e-5bf47b8b14e5}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:23Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t0\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/multiple_instances/#First-Instance","page":"Multiple instances","title":"First Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To create an instance of the FMU it is necessary to call the command fmiInstantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"comp1 = fmiInstantiate!(myFMU; loggingOn=true)\ncomp1Address= comp1.compAddr\nprintln(comp1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"FMU:            SpringPendulum1D\nInstanceName:   SpringPendulum1D\nAddress:        Ptr{Nothing} @0x0000000012938c10\nState:          0\nLogging:        1\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Next, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 100 fracNm and for the position of the mass mass.s a value of 10 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. In addition, other keywords are set. On the one hand the keyword instantiate=false is set, which prevents that in the simulation command a new instance is created. On the other hand the keyword freeInstance=false is set, this prevents that after the simulation command the instance is released. ","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"param1 = Dict(\"spring.c\"=>10.0, \"mass_s0\"=>1.0)\ndata1 = fmiSimulate(comp1, (tStart, tStop); parameters=param1, recordValues=vrs, instantiate=false, freeInstance=false)\nfig = fmiPlot(data1)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"(Image: svg)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"For control, you can compare again the address of the instance to the previous address, and it should be the same address. As soon as this is not the case an error would be thrown by the macro @assert.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert comp1.compAddr === comp1Address","category":"page"},{"location":"examples/multiple_instances/#Second-Instance","page":"Multiple instances","title":"Second Instance","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"To create a second instance of the FMU it is necessary to call the command fmiInstantiate!(). With the component address you now have a unique instance of the FMU.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"comp2 = fmiInstantiate!(myFMU; loggingOn=true)\ncomp2Address= comp2.compAddr\nprintln(comp2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"FMU:            SpringPendulum1D\nInstanceName:   SpringPendulum1D\nAddress:        Ptr{Nothing} @0x0000000012a38680\nState:          0\nLogging:        1\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"The addresses of the instantiated FMUs must differ, and you can see that in the comparison below.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert comp1Address !== comp2Address","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Again, a dictionary for the parameters is created. With this dictionary you can set the initial states of the variables of the FMU. For the spring constant spring.c a value of 10 fracNm and for the position of the mass mass.s a value of 20 m is set. The created dictionary with the specified variables for recording are passed to the command for simulation. As before, the two keywords instantiate=false and freeInstance=false are set.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"param2 = Dict(\"spring.c\"=>1.0, \"mass.s\"=>2.0)\ndata2 = fmiSimulateCS(comp2, (tStart, tStop);  parameters=param2, recordValues=vrs, instantiate=false, freeInstance=false)\nfmiPlot!(fig, data2)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"(Image: svg)","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"For control, you can compare again the address of the instance comp2 to the previous address comp2Address and it should be the same address.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"@assert comp2.compAddr === comp2Address","category":"page"},{"location":"examples/multiple_instances/#Unload-FMU","page":"Multiple instances","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/multiple_instances/#Summary","page":"Multiple instances","title":"Summary","text":"","category":"section"},{"location":"examples/multiple_instances/","page":"Multiple instances","title":"Multiple instances","text":"Based on the example it can be seen that it is possible to create different instances of an FMU. The different instances can then be used to perform different simulations.","category":"page"},{"location":"examples/parameterize/#Manually-parameterize-an-FMU","page":"Parameterize","title":"Manually parameterize an FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/parameterize/#License","page":"Parameterize","title":"License","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/parameterize/#Motivation","page":"Parameterize","title":"Motivation","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/parameterize/#Introduction-to-the-example","page":"Parameterize","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"This example shows how the manually parameterization of an FMU works if very specific adjustments during system initialization is needed. For this purpose, an IO-FMU model is loaded and the various commands for parameterization are shown on the basis of this model. With this example the user shall be guided how to make certain settings at an FMU. Please note, that parameterization of a simulation is possible in a much easier fashion: Using fmiSimulate, fmiSimulateME or fmiSimulateCS together with a parameter dictionary for the keyword parameters.","category":"page"},{"location":"examples/parameterize/#Target-group","page":"Parameterize","title":"Target group","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The example is primarily intended for users who work in the field of simulation exchange. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/parameterize/#Other-formats","page":"Parameterize","title":"Other formats","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/parameterize/#Getting-started","page":"Parameterize","title":"Getting started","text":"","category":"section"},{"location":"examples/parameterize/#Installation-prerequisites","page":"Parameterize","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"","category":"page"},{"location":"examples/parameterize/#Code-section","page":"Parameterize","title":"Code section","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# imports\nusing FMI\nusing FMIZoo","category":"page"},{"location":"examples/parameterize/#Simulation-setup","page":"Parameterize","title":"Simulation setup","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"tStart = 0.0\ntStop = 1.0\ntSave = collect(tStart:tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"2-element Vector{Float64}:\n 0.0\n 1.0","category":"page"},{"location":"examples/parameterize/#Import-FMU","page":"Parameterize","title":"Import FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"IO\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\nfmiInfo(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tIO\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{889089a6-481b-41a6-a282-f6ce02a33aa6}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:53:52Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t4\n\tInputs:\t\t\t\t3\n\t\t352321536 [\"u_real\"]\n\t\t352321537 [\"u_boolean\"]\n\t\t352321538 [\"u_integer\"]\n\tOutputs:\t\t\t3\n\t\t335544320 [\"y_real\"]\n\t\t335544321 [\"y_boolean\"]\n\t\t335544322 [\"y_integer\"]\n\tStates:\t\t\t\t0\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tIO\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tIO\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/parameterize/#Instantiate-and-Setup-FMU","page":"Parameterize","title":"Instantiate and Setup FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Next it is necessary to create an instance of the FMU. This is achieved by the command fmiInstantiate!().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiInstantiate!(myFMU; loggingOn=true)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"FMU:            IO\nInstanceName:   IO\nAddress:        Ptr{Nothing} @0x0000000010a8ce50\nState:          0\nLogging:        1\nFMU time:       -Inf\nFMU states:     nothing","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the following code block, start and end time for the simulation is set by the fmiSetupExperiment() command.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSetupExperiment(myFMU, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/#Parameterize-FMU","page":"Parameterize","title":"Parameterize FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In this example, for each data type (real, boolean, integer and string) a corresponding input or parameter is selected. From here on, the inputs and parameters will be referred to as parameters for simplicity.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"params = [\"p_real\", \"p_boolean\", \"p_integer\", \"p_string\"]","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"4-element Vector{String}:\n \"p_real\"\n \"p_boolean\"\n \"p_integer\"\n \"p_string\"","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"At the beginning we want to display the initial state of these parameters, for which the FMU must be in initialization mode. The next function fmiEnterInitializationMode() informs the FMU to enter the initialization mode. Before calling this function, the variables can be set. Furthermore, fmiSetupExperiment() must be called at least once before calling fmiEnterInitializationMode(), in order that the start time is defined.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiEnterInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The initial state of these parameters are displayed with the function fmiGet().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiGet(myFMU, params)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"4-element Vector{Any}:\n 0.0\n 0\n 0\n  \"Hello World!\"","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The initialization mode is terminated with the function fmiExitInitializationMode(). (For the model exchange FMU type, this function switches off all initialization equations, and enters the event mode implicitly.)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiExitInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next step, a function is defined that generates a random value for each parameter. For the parameter p_string a random number is inserted into the string. All parameters are combined to a tuple and output.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"function generateRandomNumbers()\n    rndReal = 100 * rand()\n    rndBoolean = rand() > 0.5\n    rndInteger = round(Integer, 100 * rand())\n    rndString = \"Random number $(100 * rand())!\"\n\n    return rndReal, rndBoolean, rndInteger, rndString\nend","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"generateRandomNumbers (generic function with 1 method)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The previously defined function is called and the results are displayed in the console.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"paramsVal = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"(67.19537042717303, false, 63, \"Random number 78.10007914014518!\")","category":"page"},{"location":"examples/parameterize/#First-variant","page":"Parameterize","title":"First variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To show the first variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiTerminate(myFMU)\nfmiReset(myFMU)\nfmiSetupExperiment(myFMU, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"[\u001b[32mOK\u001b[0m][CvodeStatistics][IO]: Sundials CVode Statistics\n    Stop time                                : 0.00 s\n    Simulation time                          : 2.56 s\n    Number of external steps                 : 0\n    Number of internal steps                 : 0\n    Number of non-linear iterations          : 0\n    Number of non-linear convergence failures: 0\n    Number of f function evaluations         : 0\n    Number of g function evaluations         : 0\n    Number of Jacobian-evaluations (direct)  : 22\n    Maximum integration order                : 0\n    Suggested tolerance scale factor         : 1.0\n    Grouping used                            : no\n\n[\u001b[32mOK\u001b[0m][][IO]: Rejected count\n    Number of external steps                 : 0\n    Number of internal steps                 : 0\n    Number of f function evaluations         : 0\n    Number of Jac function evaluations       : 0\n\n\n\n\n\n\n0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the next step it is possible to set the parameters for the FMU. With the first variant it is quickly possible to set all parameters at once. Even different data types can be set with only one command. The command fmiSet() selects itself which function is chosen for which data type.  As long as the output of the function gives the status code 0, setting the parameters has worked.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSet(myFMU, params, collect(paramsVal))","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"4-element Vector{UInt32}:\n 0x00000000\n 0x00000000\n 0x00000000\n 0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"After setting the parameters, it can be checked whether the corresponding parameters were set correctly. For this the function fmiGet() can be used as above. To be able to call the function fmiGet() the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiEnterInitializationMode(myFMU)\n# fmiGet(myFMU, params)\nfmiExitInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Now the FMU has been initialized correctly, the FMU can be simulated. The fmiSimulate() command is used for this purpose. It must be pointed out that the keywords instantiate=false, setup=false must be set. The keyword instantiate=false prevents the simulation command from creating a new FMU instance, otherwise our parameterization will be lost. The keyword setup=false prevents the FMU from calling the initialization mode again. The additionally listed keyword freeInstance=false prevents that the instance is removed after the simulation. This is only needed in this example, because we want to continue working on the created instance. Another keyword is the recordValues=parmas[1:3], which saves: p_real, p_boolean and p_integer as output. It should be noted that the fmiSimulate() function is not capable of outputting string values, so p_string is omitted.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"simData = fmiSimulate(myFMU, (tStart, tStop); recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false, freeInstance=false, terminate=false, reset=false)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Model name:\n\tIO\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 0\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 0\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 0\n\tSave values: 0\n\tSteps completed: 0\nValues [2]:\n\t0.0\t(67.19537042717303, 0.0, 63.0)\n\t1.0\t(67.19537042717303, 0.0, 63.0)\nEvents [0]:","category":"page"},{"location":"examples/parameterize/#Second-variant","page":"Parameterize","title":"Second variant","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To show the second variant, it is necessary to terminate and reset the FMU instance. Then, as before, the setup command must be called for the FMU. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiTerminate(myFMU)\nfmiReset(myFMU)\nfmiSetupExperiment(myFMU, tStart, tStop)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"[\u001b[32mOK\u001b[0m][CvodeStatistics][IO]: Sundials CVode Statistics\n    Stop time                                : 1.00 s\n    Simulation time                          : 9.15 s\n    Number of external steps                 : 1\n    Number of internal steps                 : 3\n    Number of non-linear iterations          : 3\n    Number of non-linear convergence failures: 0\n    Number of f function evaluations         : 7\n    Number of g function evaluations         : 4\n    Number of Jacobian-evaluations (direct)  : 1\n    Maximum integration order                : 1\n    Suggested tolerance scale factor         : 1.0\n    Grouping used                            : no\n\n[\u001b[32mOK\u001b[0m][][IO]: Rejected count\n    Number of external steps                 : 0\n    Number of internal steps                 : 0\n    Number of f function evaluations         : 0\n    Number of Jac function evaluations       : 0\n\n\n\n\n\n\n0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To make sure that the functions work it is necessary to generate random numbers again. As shown already, we call the defined function generateRandomNumbers() and output the values.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"rndReal, rndBoolean, rndInteger, rndString = generateRandomNumbers()","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"(83.55189738110201, false, 43, \"Random number 87.12755018538331!\")","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"In the second variant, the value for each data type is set separately by the corresponding command. By this variant one has the maximum control and can be sure that also the correct data type is set. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSetReal(myFMU, \"p_real\", rndReal)\nfmiSetBoolean(myFMU, \"p_boolean\", rndBoolean)\nfmiSetInteger(myFMU, \"p_integer\", rndInteger)\nfmiSetString(myFMU, \"p_string\", rndString)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"To illustrate the functionality of the parameterization with the separate functions, the corresponding get function can be also called separately for each data type:","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiSetReal() &#8660; fmiGetReal()\nfmiSetBoolean() &#8660; fmiGetBoolean()\nfmiSetInteger() &#8660; fmiGetInteger()\nfmiSetString() &#8660; fmiGetString().","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"As before, the FMU must be in initialization mode.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiEnterInitializationMode(myFMU)\n# fmiGetReal(myFMU, \"u_real\")\n# fmiGetBoolean(myFMU, \"u_boolean\")\n# fmiGetInteger(myFMU, \"u_integer\")\n# fmiGetString(myFMU, \"p_string\")\nfmiExitInitializationMode(myFMU)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"0x00000000","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"From here on, you may want to simulate the FMU. Please note, that with the default executionConfig, it is necessary to prevent a new instantiation using the keyword instantiate=false. Otherwise, a new instance is allocated for the simulation-call and the parameters set for the previous instance are not transfered.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"simData = fmiSimulate(myFMU, (tStart, tStop); recordValues=params[1:3], saveat=tSave, \n                        instantiate=false, setup=false)","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Model name:\n\tIO\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 0\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 0\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 0\n\tSave values: 0\n\tSteps completed: 0\nValues [2]:\n\t0.0\t(83.55189738110201, 0.0, 43.0)\n\t1.0\t(83.55189738110201, 0.0, 43.0)\nEvents [0]:","category":"page"},{"location":"examples/parameterize/#Unload-FMU","page":"Parameterize","title":"Unload FMU","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"The FMU will be unloaded and all unpacked data on disc will be removed.","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/parameterize/#Summary","page":"Parameterize","title":"Summary","text":"","category":"section"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"Based on this tutorial it can be seen that there are two different variants to set and get parameters.These examples should make it clear to the user how parameters can also be set with different data types. As a small reminder, the sequence of commands for the manual parameterization of an FMU is summarized again. ","category":"page"},{"location":"examples/parameterize/","page":"Parameterize","title":"Parameterize","text":"fmiLoad() &#8594; fmiInstantiate!() &#8594; fmiSetupExperiment() &#8594; fmiSetXXX() &#8594; fmiEnterInitializationMode() &#8594; fmiGetXXX() &#8594; fmiExitInitializationMode() &#8594; fmiSimualte() &#8594; fmiUnload()","category":"page"},{"location":"examples/parameter_optimization/#FMU-Parameter-Optimization","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Tutorial by Tobias Thummerer","category":"page"},{"location":"examples/parameter_optimization/#License","page":"FMU Parameter Optimization","title":"License","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/parameter_optimization/#Introduction-to-the-example","page":"FMU Parameter Optimization","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"This example shows how a parameter optimization can be set up for a FMU. The goal is to fit FMU parameters (and initial states), so that a reference trajectory is fit as good as possible.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Note, that this tutorial covers optimization without gradient information. Basically, FMI.jl supports gradient based optimization, too.","category":"page"},{"location":"examples/parameter_optimization/#Other-formats","page":"FMU Parameter Optimization","title":"Other formats","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/parameter_optimization/#Getting-started","page":"FMU Parameter Optimization","title":"Getting started","text":"","category":"section"},{"location":"examples/parameter_optimization/#Installation-prerequisites","page":"FMU Parameter Optimization","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":" Description Command\n1. Enter Package Manager via ]\n2. Install FMI via add FMI\n3. Install FMIZoo via add FMIZoo\n4. Install Optim  via add Optim\n5. Install Plots  via add Plots","category":"page"},{"location":"examples/parameter_optimization/#Code-section","page":"FMU Parameter Optimization","title":"Code section","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# imports\nusing FMI\nusing FMIZoo\nusing Optim\nusing Plots","category":"page"},{"location":"examples/parameter_optimization/#Simulation-setup","page":"FMU Parameter Optimization","title":"Simulation setup","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"tStart = 0.0\ntStop = 5.0\ntStep = 0.1\ntSave = tStart:tStep:tStop","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"0.0:0.1:5.0","category":"page"},{"location":"examples/parameter_optimization/#Import-FMU","page":"FMU Parameter Optimization","title":"Import FMU","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"# we use an FMU from the FMIZoo.jl\nfmu = fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\"; type=:ME)\nfmiInfo(fmu)","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{fc15d8c4-758b-48e6-b00e-5bf47b8b14e5}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:23Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t0\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Now, the optimization objective (the function to minimize) needs to be defined. In this case, we just want to do a simulation and compare it to a regular sin wave.","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_tar = 1.0 .+ sin.(tSave)\n\n# a function to simulate the FMU for given parameters\nfunction simulateFMU(p)\n    s0, v0, c, m = p # unpack parameters: s0 (start position), v0 (start velocity), c (spring constant) and m (pendulum mass)\n\n    # pack the parameters into a dictionary\n    paramDict = Dict{String, Any}()\n    paramDict[\"spring.c\"] = c \n    paramDict[\"mass.m\"] = m\n\n    # pack the start state\n    x0 = [s0, v0]\n\n    # simulate with given start stae and parameters\n    sol = fmiSimulate(fmu, (tStart, tStop); x0=x0, parameters=paramDict, saveat=tSave)\n\n    # get state with index 1 (the position) from the solution\n    s_res = fmiGetSolutionState(sol, 1; isIndex=true) \n\n    return s_res\nend\n\n# the optimization objective\nfunction objective(p)\n    s_res = simulateFMU(p)\n\n    # return the position error sum between FMU simulation (s_res) and target (s_tar)\n    return sum(abs.(s_tar .- s_res))    \nend","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"objective (generic function with 1 method)","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Now let's see how far we are away for our guess parameters:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s0 = 0.0 \nv0 = 0.0\nc = 1.0\nm = 1.0 \np = [s0, v0, c, m]\n\nobj_before = objective(p) # not really good!","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mUsing arrays or dicts to store parameters of different types can hurt performance.\n\u001b[33m\u001b[1m│ \u001b[22m\u001b[39mConsider using tuples instead.\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ SciMLBase ~/.julia/packages/SciMLBase/wvDeR/src/performance_warnings.jl:32\u001b[39m\n\u001b[34mSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:27\u001b[39m\n\n\n\n\n\n54.43219974960283","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Let's have a look on the differences:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_fmu = simulateFMU(p); # simulate the position\n\nplot(tSave, s_fmu; label=\"FMU\")\nplot!(tSave, s_tar; label=\"Optimization target\")","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"(Image: svg)","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Not that good. So let's do a bit of optimization!","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"opt = Optim.optimize(objective, p; iterations=250) # do max. 250 iterations\nobj_after = opt.minimum # much better!\np_res = opt.minimizer # the optimized parameters","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"4-element Vector{Float64}:\n 1.000000090936486\n 0.9779757996615742\n 0.130860011492463\n 0.11402874395172038","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Looks promising, let's have a look on the results plot:","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"s_fmu = simulateFMU(p_res); # simulate the position\n\nplot(tSave, s_fmu; label=\"FMU\")\nplot!(tSave, s_tar; label=\"Optimization target\")","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"(Image: svg)","category":"page"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"Actually a pretty fit! If you have higher requirements, check out the Optim.jl library.","category":"page"},{"location":"examples/parameter_optimization/#Summary","page":"FMU Parameter Optimization","title":"Summary","text":"","category":"section"},{"location":"examples/parameter_optimization/","page":"FMU Parameter Optimization","title":"FMU Parameter Optimization","text":"This tutorial showed how a parameter (and start value) optimization can be performed on a FMU with a gradient free optimizer. This tutorial will be extended soon to further show how convergence for large parameter spaces can be improoved!","category":"page"},{"location":"examples/manipulation/#Manipulate-a-function","page":"Manipulation","title":"Manipulate a function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Tutorial by Johannes Stoljar, Tobias Thummerer","category":"page"},{"location":"examples/manipulation/#License","page":"Manipulation","title":"License","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/manipulation/#Motivation","page":"Manipulation","title":"Motivation","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/manipulation/#Introduction-to-the-example","page":"Manipulation","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"This example shows how to overwrite a library function with an own function. For this the FMU model is simulated first without changes. Then the function fmi2GetReal() is overwritten and simulated again. Both simulations are displayed in a graph to show the change caused by overwriting the function. The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"(Image: svg)  ","category":"page"},{"location":"examples/manipulation/#Target-group","page":"Manipulation","title":"Target group","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/manipulation/#Other-formats","page":"Manipulation","title":"Other formats","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/manipulation/#Getting-started","page":"Manipulation","title":"Getting started","text":"","category":"section"},{"location":"examples/manipulation/#Installation-prerequisites","page":"Manipulation","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install Plots via add Plots ","category":"page"},{"location":"examples/manipulation/#Code-section","page":"Manipulation","title":"Code section","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# imports\nusing FMI\nusing FMI: fmiSetFctGetReal\nusing FMIZoo\nusing FMICore\nusing Plots","category":"page"},{"location":"examples/manipulation/#Simulation-setup","page":"Manipulation","title":"Simulation setup","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Next, the start time and end time of the simulation are set.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"tStart = 0.0\ntStop = 8.0","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"8.0","category":"page"},{"location":"examples/manipulation/#Import-FMU","page":"Manipulation","title":"Import FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the next lines of code the FMU model from FMIZoo.jl is loaded and the information about the FMU is shown.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# we use an FMU from the FMIZoo.jl\npathToFMU = get_model_filename(\"SpringFrictionPendulum1D\", \"Dymola\", \"2022x\")\n\nmyFMU = fmiLoad(pathToFMU)\n\nfmiInfo(myFMU)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"#################### Begin information for FMU ####################\n\tModel name:\t\t\tSpringFrictionPendulum1D\n\tFMI-Version:\t\t\t2.0\n\tGUID:\t\t\t\t{2e178ad3-5e9b-48ec-a7b2-baa5669efc0c}\n\tGeneration tool:\t\tDymola Version 2022x (64-bit), 2021-10-08\n\tGeneration time:\t\t2022-05-19T06:54:12Z\n\tVar. naming conv.:\t\tstructured\n\tEvent indicators:\t\t24\n\tInputs:\t\t\t\t0\n\tOutputs:\t\t\t0\n\tStates:\t\t\t\t2\n\t\t33554432 [\"mass.s\"]\n\t\t33554433 [\"mass.v\", \"mass.v_relfric\"]\n\tSupports Co-Simulation:\t\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n\t\tVar. com. steps:\ttrue\n\t\tInput interpol.:\ttrue\n\t\tMax order out. der.:\t1\n\tSupports Model-Exchange:\ttrue\n\t\tModel identifier:\tSpringFrictionPendulum1D\n\t\tGet/Set State:\t\ttrue\n\t\tSerialize State:\ttrue\n\t\tDir. Derivatives:\ttrue\n##################### End information for FMU #####################","category":"page"},{"location":"examples/manipulation/#Simulate-FMU","page":"Manipulation","title":"Simulate FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the next steps the recorded value is defined. The recorded value is the position of the mass. In the function fmiSimulateME() the FMU is simulated in model-exchange mode (ME) with an adaptive step size. In addition, the start and end time and the recorded variables are specified.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"vrs = [\"mass.s\"]\n\nsimData = fmiSimulateME(myFMU, (tStart, tStop); recordValues=vrs)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mUsing arrays or dicts to store parameters of different types can hurt performance.\n\u001b[33m\u001b[1m│ \u001b[22m\u001b[39mConsider using tuples instead.\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ SciMLBase ~/.julia/packages/SciMLBase/wvDeR/src/performance_warnings.jl:32\u001b[39m\n\u001b[34mSimulating ME-FMU ... 100%|██████████████████████████████| Time: 0:00:20\u001b[39m\n\n\n\n\n\nModel name:\n\tSpringFrictionPendulum1D\nSuccess:\n\ttrue\nf(x)-Evaluations:\n\tIn-place: 1377\n\tOut-of-place: 0\nJacobian-Evaluations:\n\t∂ẋ_∂x: 0\n\t∂ẋ_∂u: 0\n\t∂y_∂x: 0\n\t∂y_∂u: 0\nGradient-Evaluations:\n\t∂ẋ_∂t: 0\n\t∂y_∂t: 0\nCallback-Evaluations:\n\tCondition (event-indicators): 1893\n\tTime-Choice (event-instances): 0\n\tAffect (event-handling): 6\n\tSave values: 131\n\tSteps completed: 131\nStates [131]:\n\t0.0\t[0.5, 0.0]\n\t2.352941176471972e-11\t[0.5, 1.0e-10]\n\t0.002306805098500577\t[0.50001131604032, 0.009814511243552598]\n\t0.01777270244764722\t[0.5006746897285066, 0.0761020888387732]\n\t0.05358198534179392\t[0.5061791781920479, 0.231641032514133]\n\t0.11852691526990361\t[0.5303834643745903, 0.5124206161359472]\n\t0.1848828094709355\t[0.573492996354974, 0.7828256191561919]\n\t0.2648828094709355\t[0.6478174725986621, 1.0657732960206507]\n\t0.3448828094709355\t[0.7422425202486511, 1.2823803113750607]\n\t...\n\t8.0\t[1.0666322778272936, -7.60398591662422e-5]\nValues [131]:\n\t0.0\t(0.5,)\n\t2.352941176471972e-11\t(0.5,)\n\t0.002306805098500577\t(0.50001131604032,)\n\t0.01777270244764722\t(0.5006746897285066,)\n\t0.05358198534179392\t(0.5061791781920479,)\n\t0.11852691526990361\t(0.5303834643745903,)\n\t0.1848828094709355\t(0.573492996354974,)\n\t0.2648828094709355\t(0.6478174725986621,)\n\t0.3448828094709355\t(0.7422425202486511,)\n\t...\n\t8.0\t(1.0666322778272936,)\nEvents [6]:\n\tState-Event #11 @ 0.0s\n\tState-Event #11 @ 0.994s\n\tState-Event #19 @ 1.9883s\n\tState-Event #11 @ 2.9831s\n\tState-Event #19 @ 3.9789s\n\tState-Event #11 @ 4.977s","category":"page"},{"location":"examples/manipulation/#Plotting-FMU","page":"Manipulation","title":"Plotting FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After the simulation is finished, the result of the FMU for the model-exchange mode can be plotted. In the plot for the FMU it can be seen that the oscillation continues to decrease due to the effect of the friction. If you simulate long enough, the oscillation comes to a standstill in a certain time.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"fig = fmiPlot(simData, states=false)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"(Image: svg)","category":"page"},{"location":"examples/manipulation/#Override-Function","page":"Manipulation","title":"Override Function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After overwriting a function, the previous one is no longer accessible. The original function fmi2GetReal() is cached by storing the address of the pointer. The addresses of the pointers are kept in the FMU and are thus accessible.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# save, where the original `fmi2GetReal` function was stored, so we can access it in our new function\noriginalGetReal = myFMU.cGetReal","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Ptr{Nothing} @0x00007f907748efaf","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"To overwrite the function fmi2GetReal!(), the function header of the new custom function must be identical to the previous one. The function header looks like fmi2GetReal!(cfunc::Ptr{Nothing}, c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})::fmi2Status. The information how the FMI2 function are structured can be seen from FMICore.jl or the FMI2.0.3-specification.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the new implementation the original function is called by the previously stored pointer. Next there is a special handling if value is a pointer to an array. In this case the pointer is treated as an array, so that the entries are accessible. Otherwise, each value in value is multiplied by two. Finally, the original state of the original function is output.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"function myGetReal!(c::fmi2Component, vr::Union{Array{fmi2ValueReference}, Ptr{fmi2ValueReference}}, \n                    nvr::Csize_t, value::Union{Array{fmi2Real}, Ptr{fmi2Real}})\n    # first, we do what the original function does\n    status = fmi2GetReal!(originalGetReal, c, vr, nvr, value)\n\n    # if we have a pointer to an array, we must interprete it as array to access elements\n    if isa(value, Ptr{fmi2Real})\n        value = unsafe_wrap(Array{fmi2Real}, value, nvr, own=false)\n    end\n\n    # now, we multiply every value by two (just for fun!)\n    for i in 1:nvr \n        value[i] *= 2.0 \n    end \n\n    # return the original status\n    return status\nend","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"myGetReal! (generic function with 1 method)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In the next command the original function is overwritten with the new defined function, for which the command fmiSetFctGetReal() is called.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"# no we overwrite the original function\nfmiSetFctGetReal(myFMU, myGetReal!)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"Ptr{Nothing} @0x00007f917b41bfc0","category":"page"},{"location":"examples/manipulation/#Simulate-and-Plot-FMU-with-modified-function","page":"Manipulation","title":"Simulate and Plot FMU with modified function","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"As before, the identical command is called here for simulation. This is also a model exchange simulation. Immediately afterwards, the results are added to the previous graph as a dashed line.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"simData = fmiSimulateME(myFMU, (tStart, tStop); recordValues=vrs)\nfmiPlot!(fig, simData; states=false, style=:dash)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"(Image: svg)","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"As expected by overwriting the function, all values are doubled.","category":"page"},{"location":"examples/manipulation/#Unload-FMU","page":"Manipulation","title":"Unload FMU","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"After plotting the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"fmiUnload(myFMU)","category":"page"},{"location":"examples/manipulation/#Summary","page":"Manipulation","title":"Summary","text":"","category":"section"},{"location":"examples/manipulation/","page":"Manipulation","title":"Manipulation","text":"In this tutorial it is shown how an existing function of the library can be replaced by an own implementation. Through this possibility, there are almost no limits for the user, whereby the user can customize the function to his liking.","category":"page"},{"location":"fmi2_library/#library","page":"Developer Level API","title":"FMI2 Library Functions","text":"","category":"section"},{"location":"fmi2_library/#FMI2-Common-Concepts-for-Model-Exchange-and-Co-Simulation","page":"Developer Level API","title":"FMI2 Common Concepts for Model Exchange and Co-Simulation","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"In both cases, FMI defines an input/output block of a dynamic model where the distribution of the block, the platform dependent header file, several access functions, as well as the schema files are identical.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"FMU2\nFMU2Component\nfmi2Struct","category":"page"},{"location":"fmi2_library/#FMICore.FMU2","page":"Developer Level API","title":"FMICore.FMU2","text":"The mutable struct representing a FMU (and a container for all its instances) in the FMI 2.0.2 Standard. Also contains the paths to the FMU and ZIP folder as well als all the FMI 2.0.2 function pointers.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_library/#FMICore.FMU2Component","page":"Developer Level API","title":"FMICore.FMU2Component","text":"The mutable struct represents an allocated instance of an FMU in the FMI 2.0.2 Standard.\n\n\n\n\n\n","category":"type"},{"location":"fmi2_library/#Reading-the-model-description","page":"Developer Level API","title":"Reading the model description","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"This section documents functions to inquire information about the model description of an FMU.","category":"page"},{"location":"fmi2_library/#Load/Parse-the-FMI-model-description","page":"Developer Level API","title":"Load/Parse the FMI model description","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2LoadModelDescription","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2LoadModelDescription","page":"Developer Level API","title":"FMIImport.fmi2LoadModelDescription","text":"fmi2LoadModelDescription(pathToModelDescription::String)\n\nExtract the FMU variables and meta data from the ModelDescription\n\nArguments\n\npathToModelDescription::String: Contains the path to a file name that is selected to be read and converted to an XML document. In order to better extract the variables and meta data in the further process.\n\nReturns\n\nmd::fmi2ModelDescription: Retuns a struct which provides the static information of ModelVariables.\n\nSource\n\nEzXML.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Get-value-functions","page":"Developer Level API","title":"Get value functions","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2GetDefaultStartTime\nfmi2GetDefaultStopTime\nfmi2GetDefaultTolerance\nfmi2GetDefaultStepSize\nfmi2GetModelName\nfmi2GetGUID\nfmi2GetGenerationTool\nfmi2GetGenerationDateAndTime\nfmi2GetVariableNamingConvention\nfmi2GetNumberOfEventIndicators\nfmi2GetNumberOfStates\nfmi2IsCoSimulation\nfmi2IsModelExchange","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2GetDefaultStartTime","page":"Developer Level API","title":"FMIImport.fmi2GetDefaultStartTime","text":"fmi2GetDefaultStartTime(md::fmi2ModelDescription)\n\nReturns startTime from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.startTime::Union{Real,Nothing}: Returns a real value startTime from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetDefaultStopTime","page":"Developer Level API","title":"FMIImport.fmi2GetDefaultStopTime","text":"fmi2GetDefaultStopTime(md::fmi2ModelDescription)\n\nReturns stopTime from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.stopTime::Union{Real,Nothing}: Returns a real value stopTime from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetDefaultTolerance","page":"Developer Level API","title":"FMIImport.fmi2GetDefaultTolerance","text":"fmi2GetDefaultTolerance(md::fmi2ModelDescription)\n\nReturns tolerance from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.tolerance::Union{Real,Nothing}: Returns a real value tolerance from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetDefaultStepSize","page":"Developer Level API","title":"FMIImport.fmi2GetDefaultStepSize","text":"fmi2GetDefaultStepSize(md::fmi2ModelDescription)\n\nReturns stepSize from DefaultExperiment if defined else defaults to nothing.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.defaultExperiment.stepSize::Union{Real,Nothing}: Returns a real value setpSize from the DefaultExperiment if defined else defaults to nothing.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetModelName","page":"Developer Level API","title":"FMIImport.fmi2GetModelName","text":"fmi2GetModelName(md::fmi2ModelDescription)\n\nReturns the tag 'modelName' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.modelName::String: Returns the tag 'modelName' from the model description.\n\n\n\n\n\nfunction fmi2GetModelName(fmu::FMU2)\n\nReturns the tag 'modelName' from the model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nfmu.modelDescription.modelName::String: Returns the tag 'modelName' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetGUID","page":"Developer Level API","title":"FMIImport.fmi2GetGUID","text":"fmi2GetGUID(md::fmi2ModelDescription)\n\nReturns the tag 'guid' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.guid::String: Returns the tag 'guid' from the model description.\n\n\n\n\n\nfmi2GetGUID(fmu::FMU2)\n\nReturns the tag 'guid' from the model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nfmu.modelDescription.guid::String: Returns the tag 'guid' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetGenerationTool","page":"Developer Level API","title":"FMIImport.fmi2GetGenerationTool","text":"fmi2GetGenerationTool(md::fmi2ModelDescription)\n\nReturns the tag 'generationtool' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.generationTool::Union{String, Nothing}: Returns the tag 'generationtool' from the model description.\n\n\n\n\n\nfmi2GetGenerationTool(fmu::FMU2)\n\nReturns the tag 'generationtool' from the model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nfmu.modelDescription.generationTool::Union{String, Nothing}: Returns the tag 'generationtool' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetGenerationDateAndTime","page":"Developer Level API","title":"FMIImport.fmi2GetGenerationDateAndTime","text":"fmi2GetGenerationDateAndTime(md::fmi2ModelDescription)\n\nReturns the tag 'generationdateandtime' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.generationDateAndTime::DateTime: Returns the tag 'generationdateandtime' from the model description.\n\n\n\n\n\nfmi2GetGenerationDateAndTime(fmu::FMU2)\n\nReturns the tag 'generationdateandtime' from the model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nfmu.modelDescription.generationDateAndTime::DateTime: Returns the tag 'generationdateandtime' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetVariableNamingConvention","page":"Developer Level API","title":"FMIImport.fmi2GetVariableNamingConvention","text":"fmi2GetVariableNamingConvention(md::fmi2ModelDescription)\n\nReturns the tag 'varaiblenamingconvention' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.variableNamingConvention::Union{fmi2VariableNamingConvention, Nothing}: Returns the tag 'variableNamingConvention' from the model description.\n\n\n\n\n\nfmi2GetVariableNamingConvention(fmu::FMU2)\n\nReturns the tag 'varaiblenamingconvention' from the model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nfmu.modelDescription.variableNamingConvention::Union{fmi2VariableNamingConvention, Nothing}: Returns the tag 'variableNamingConvention' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetNumberOfEventIndicators","page":"Developer Level API","title":"FMIImport.fmi2GetNumberOfEventIndicators","text":"fmi2GetNumberOfEventIndicators(md::fmi2ModelDescription)\n\nReturns the tag 'numberOfEventIndicators' from the model description.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nmd.numberOfEventIndicators::Union{UInt, Nothing}: Returns the tag 'numberOfEventIndicators' from the model description.\n\n\n\n\n\nfmi2GetNumberOfEventIndicators(fmu::FMU2)\n\nReturns the tag 'numberOfEventIndicators' from the model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nfmu.modelDescription.numberOfEventIndicators::Union{UInt, Nothing}: Returns the tag 'numberOfEventIndicators' from the model description.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetNumberOfStates","page":"Developer Level API","title":"FMIImport.fmi2GetNumberOfStates","text":"fmi2GetNumberOfStates(md::fmi2ModelDescription)\n\nReturns the number of states of the FMU.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\nReturns the length of the md.valueReferences::Array{fmi2ValueReference} corresponding to the number of states of the FMU.\n\n\n\n\n\nfmi2GetNumberOfStates(fmu::FMU2)\n\nReturns the number of states of the FMU.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns the length of the fmu.modelDescription.valueReferences::Array{fmi2ValueReference} corresponding to the number of states of the FMU.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2IsCoSimulation","page":"Developer Level API","title":"FMIImport.fmi2IsCoSimulation","text":"fmi2IsCoSimulation(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports co simulation\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports co simulation\n\n\n\n\n\nfmi2IsCoSimulation(fmu::FMU2)\n\nReturns true, if the FMU supports co simulation\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\n::Bool: Returns true, if the FMU supports co simulation\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2IsModelExchange","page":"Developer Level API","title":"FMIImport.fmi2IsModelExchange","text":"fmi2IsModelExchange(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports model exchange\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports model exchange\n\n\n\n\n\nfmi2IsModelExchange(fmu::FMU2)\n\nReturns true, if the FMU supports model exchange\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\n::Bool: Returns true, if the FMU supports model exchange\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Information-functions","page":"Developer Level API","title":"Information functions","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2DependenciesSupported\nfmi2DerivativeDependenciesSupported\nfmi2GetModelIdentifier\nfmi2CanGetSetState\nfmi2CanSerializeFMUstate\nfmi2ProvidesDirectionalDerivative\nfmi2GetValueReferencesAndNames\nfmi2GetNames\nfmi2GetModelVariableIndices\nfmi2GetInputValueReferencesAndNames\nfmi2GetInputNames\nfmi2GetOutputValueReferencesAndNames\nfmi2GetOutputNames\nfmi2GetParameterValueReferencesAndNames\nfmi2GetParameterNames\nfmi2GetStateValueReferencesAndNames\nfmi2GetStateNames\nfmi2GetDerivateValueReferencesAndNames\nfmi2GetDerivativeNames\nfmi2GetNamesAndDescriptions\nfmi2GetNamesAndUnits\nfmi2GetNamesAndInitials\nfmi2GetInputNamesAndStarts\nfmi2GetVersion\nfmi2GetTypesPlatform\nfmi2GetSolutionDerivative","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2DependenciesSupported","page":"Developer Level API","title":"FMIImport.fmi2DependenciesSupported","text":"fmi2DependenciesSupported(md::fmi2ModelDescription)\n\nReturns true if the FMU model description contains dependency information.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU model description contains dependency information.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2DerivativeDependenciesSupported","page":"Developer Level API","title":"FMIImport.fmi2DerivativeDependenciesSupported","text":"fmi2DerivativeDependenciesSupported(md::fmi2ModelDescription)\n\nReturns if the FMU model description contains dependency information for derivatives.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU model description contains dependency information for derivatives.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetModelIdentifier","page":"Developer Level API","title":"FMIImport.fmi2GetModelIdentifier","text":"fmi2GetModelIdentifier(md::fmi2ModelDescription; type=nothing)\n\nReturns the tag 'modelIdentifier' from CS or ME section.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\ntype=nothing: Defines whether a Co-Simulation or Model Exchange is present. (default = nothing)\n\nReturns\n\nmd.modelExchange.modelIdentifier::String: Returns the tag modelIdentifier from ModelExchange section.\nmd.coSimulation.modelIdentifier::String: Returns the tag modelIdentifier from CoSimulation section.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2CanGetSetState","page":"Developer Level API","title":"FMIImport.fmi2CanGetSetState","text":"fmi2CanGetSetState(md::fmi2ModelDescription)\n\nReturns true, if the FMU supports the getting/setting of states\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU supports the getting/setting of states.\n\n\n\n\n\nfmi2CanGetSetState(fmu::FMU2)\n\nReturns true, if the FMU supports the getting/setting of states\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\n::Bool: Returns true, if the FMU supports the getting/setting of states.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2CanSerializeFMUstate","page":"Developer Level API","title":"FMIImport.fmi2CanSerializeFMUstate","text":"fmi2CanSerializeFMUstate(md::fmi2ModelDescription)\n\nReturns true, if the FMU state can be serialized\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU state can be serialized\n\n\n\n\n\nfmi2CanSerializeFMUstate(fmu::FMU2)\n\nReturns true, if the FMU state can be serialized\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\n::Bool: Returns true, if the FMU state can be serialized\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2ProvidesDirectionalDerivative","page":"Developer Level API","title":"FMIImport.fmi2ProvidesDirectionalDerivative","text":"fmi2ProvidesDirectionalDerivative(md::fmi2ModelDescription)\n\nReturns true, if the FMU provides directional derivatives\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\n::Bool: Returns true, if the FMU provides directional derivatives\n\n\n\n\n\nfmi2ProvidesDirectionalDerivative(fmu::FMU2)\n\nReturns true, if the FMU provides directional derivatives\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\n::Bool: Returns true, if the FMU provides directional derivatives\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetValueReferencesAndNames","page":"Developer Level API","title":"FMIImport.fmi2GetValueReferencesAndNames","text":"fmi2GetValueReferencesAndNames(md::fmi2ModelDescription; vrs=md.valueReferences)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.\n\n\n\n\n\nfmi2GetValueReferencesAndNames(fmu::FMU2)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetNames","page":"Developer Level API","title":"FMIImport.fmi2GetNames","text":"fmi2GetNames(md::fmi2ModelDescription; vrs=md.valueReferences, mode=:first)\n\nReturns a array of names corresponding to value references vrs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\nfmi2GetNames(fmu::FMU2; vrs=md.valueReferences, mode=:first)\n\nReturns a array of names corresponding to value references vrs.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetModelVariableIndices","page":"Developer Level API","title":"FMIImport.fmi2GetModelVariableIndices","text":"fmi2GetModelVariableIndices(md::fmi2ModelDescription; vrs=md.valueReferences)\n\nReturns a array of indices corresponding to value references vrs\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.valueReferences: Additional attribute valueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\n\nReturns\n\nnames::Array{Integer}: Returns a array of indices corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetInputValueReferencesAndNames","page":"Developer Level API","title":"FMIImport.fmi2GetInputValueReferencesAndNames","text":"fmi2GetInputValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dict with (vrs, names of inputs).\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of inputs)\n\n\n\n\n\nfmi2GetInputValueReferencesAndNames(fmu::FMU2)\n\nReturns a dict with (vrs, names of inputs).\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of inputs)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetInputNames","page":"Developer Level API","title":"FMIImport.fmi2GetInputNames","text":"fmi2GetInputNames(md::fmi2ModelDescription; vrs=md.inputvalueReferences, mode=:first)\n\nReturns names of inputs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.inputvalueReferences: Additional attribute inputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\nfmi2GetInputNames(fmu::FMU2; vrs=md.inputValueReferences, mode=:first)\n\nReturns names of inputs.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\nvrs=md.inputvalueReferences: Additional attribute inputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.valueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetOutputValueReferencesAndNames","page":"Developer Level API","title":"FMIImport.fmi2GetOutputValueReferencesAndNames","text":"fmi2GetOutputValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.outputvalueReferences: Additional attribute outputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.outputvalueReferences::Array{fmi2ValueReference})\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.So returns a dict with (vrs, names of outputs)\n\n\n\n\n\nfmi2GetOutputValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of value references and their corresponding names.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}.So returns a dict with (vrs, names of outputs)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetOutputNames","page":"Developer Level API","title":"FMIImport.fmi2GetOutputNames","text":"fmi2GetOutputNames(md::fmi2ModelDescription; vrs=md.outputvalueReferences, mode=:first)\n\nReturns names of outputs.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.outputvalueReferences: Additional attribute outputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.outputvalueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\nfmi2GetOutputNames(fmu::FMU2; vrs=md.outputvalueReferences, mode=:first)\n\nReturns names of outputs.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\nvrs=md.outputvalueReferences: Additional attribute outputvalueReferences::Array{fmi2ValueReference} of the Model Description that is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.outputvalueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetParameterValueReferencesAndNames","page":"Developer Level API","title":"FMIImport.fmi2GetParameterValueReferencesAndNames","text":"fmi2GetParameterValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of parameterValueReferences and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of parameters).\n\nSee also fmi2GetValueReferencesAndNames.\n\n\n\n\n\nfmi2GetParameterValueReferencesAndNames(fmu::FMU2)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of parameterValueReferences and their corresponding names.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of parameters).\n\nSee also fmi2GetValueReferencesAndNames.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetParameterNames","page":"Developer Level API","title":"FMIImport.fmi2GetParameterNames","text":"fmi2GetParameterNames(md::fmi2ModelDescription; vrs=md.parameterValueReferences, mode=:first)\n\nReturns names of parameters.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.parameterValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.parameterValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\nfmi2GetParameterNames(fmu::FMU2; vrs=md.parameterValueReferences, mode=:first)\n\nReturns names of parameters.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\nvrs=md.parameterValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.parameterValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetStateValueReferencesAndNames","page":"Developer Level API","title":"FMIImport.fmi2GetStateValueReferencesAndNames","text":"fmi2GetStateValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of state value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of states)\n\n\n\n\n\nfmi2GetStateValueReferencesAndNames(fmu::FMU2)\n\nReturns dict(vrs, names of states).\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of state value references and their corresponding names.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of states)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetStateNames","page":"Developer Level API","title":"FMIImport.fmi2GetStateNames","text":"fmi2GetStateNames(fmu::FMU2; vrs=md.stateValueReferences, mode=:first)\n\nReturns names of states.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.stateValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.stateValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\nfmi2GetStateNames(fmu::FMU2; vrs=md.stateValueReferences, mode=:first)\n\nReturns names of states.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\nvrs=md.stateValueReferences: Additional attribute parameterValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.stateValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetDerivateValueReferencesAndNames","page":"Developer Level API","title":"FMIImport.fmi2GetDerivateValueReferencesAndNames","text":"fmi2GetDerivateValueReferencesAndNames(md::fmi2ModelDescription)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of derivative value references and their corresponding names.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of derivatives)\n\nSee also fmi2GetValueReferencesAndNames`\n\n\n\n\n\nfmi2GetDerivateValueReferencesAndNames(fmu::FMU2)\n\nReturns a dictionary Dict(fmi2ValueReference, Array{String}) of derivative value references and their corresponding names.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{fmi2ValueReference, Array{String}}: Returns a dictionary that constructs a hash table with keys of type fmi2ValueReference and values of type Array{String}. So returns a dict with (vrs, names of derivatives)\n\nSee also fmi2GetValueReferencesAndNames`\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetDerivativeNames","page":"Developer Level API","title":"FMIImport.fmi2GetDerivativeNames","text":"fmi2GetDerivativeNames(md::fmi2ModelDescription; vrs=md.derivativeValueReferences, mode=:first)\n\nReturns names of derivatives.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nKeywords\n\nvrs=md.derivativeValueReferences: Additional attribute derivativeValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.derivativeValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\nfmi2GetDerivativeNames(fmu::FMU2; vrs=md.derivativeValueReferences, mode=:first)\n\nReturns names of derivatives.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\nvrs=md.derivativeValueReferences: Additional attribute derivativeValueReferences::Array{fmi2ValueReference} of the Model Description that  is a handle to a (base type) variable value. Handle and base type uniquely identify the value of a variable. (default = md.derivativeValueReferences::Array{fmi2ValueReference})\nmode=:first: If there are multiple names per value reference, availabel modes are :first (default, pick only the first one), :group (pick all and group them into an array) and :flat (pick all, but flat them out into a 1D-array together with all other names)\n\nReturns\n\nnames::Array{String}: Returns a array of names corresponding to parameter value references vrs\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetNamesAndDescriptions","page":"Developer Level API","title":"FMIImport.fmi2GetNamesAndDescriptions","text":"fmi2GetNamesAndDescriptions(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their descriptions.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].description::Union{String, Nothing}). (Creates a tuple (name, description) for each i in 1:length(md.modelVariables))\n\n\n\n\n\nfmi2GetNamesAndDescriptions(fmu::FMU2)\n\nReturns a dictionary of variables with their descriptions.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].description::Union{String, Nothing}). (Creates a tuple (name, description) for each i in 1:length(md.modelVariables))\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetNamesAndUnits","page":"Developer Level API","title":"FMIImport.fmi2GetNamesAndUnits","text":"fmi2GetNamesAndUnits(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their units.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i]._Real.unit::Union{String, Nothing}). (Creates a tuple (name, unit) for each i in 1:length(md.modelVariables))\n\nSee also fmi2GetUnit.\n\n\n\n\n\nfmi2GetNamesAndUnits(fmu::FMU2)\n\nReturns a dictionary of variables with their units.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{String, String}: Returns a dictionary that constructs a hash table with keys of type String and values of type String. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i]._Real.unit::Union{String, Nothing}). (Creates a tuple (name, unit) for each i in 1:length(md.modelVariables))\n\nSee also fmi2GetUnit.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetNamesAndInitials","page":"Developer Level API","title":"FMIImport.fmi2GetNamesAndInitials","text":"fmi2GetNamesAndInitials(md::fmi2ModelDescription)\n\nReturns a dictionary of variables with their initials.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, Cuint}: Returns a dictionary that constructs a hash table with keys of type String and values of type Cuint. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].inital::Union{fmi2Initial, Nothing}). (Creates a tuple (name,initial) for each i in 1:length(md.modelVariables))\n\nSee also fmi2GetInitial.\n\n\n\n\n\nfmi2GetNamesAndInitials(fmu::FMU2)\n\nReturns a dictionary of variables with their initials.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{String, Cuint}: Returns a dictionary that constructs a hash table with keys of type String and values of type Cuint. So returns a dict with ( md.modelVariables[i].name::String, md.modelVariables[i].inital::Union{fmi2Initial, Nothing}). (Creates a tuple (name,initial) for each i in 1:length(md.modelVariables))\n\nSee also fmi2GetInitial.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetInputNamesAndStarts","page":"Developer Level API","title":"FMIImport.fmi2GetInputNamesAndStarts","text":"fmi2GetInputNamesAndStarts(md::fmi2ModelDescription)\n\nReturns a dictionary of input variables with their starting values.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\n\nReturns\n\ndict::Dict{String, Array{fmi2ValueReferenceFormat}}: Returns a dictionary that constructs a hash table with keys of type String and values of type fmi2ValueReferenceFormat. So returns a dict with ( md.modelVariables[i].name::String, starts:: Array{fmi2ValueReferenceFormat} ). (Creates a tuple (name, starts) for each i in inputIndices)\n\nSee also fmi2GetStartValue.\n\n\n\n\n\nfmi2GetInputNamesAndStarts(fmu::FMU2)\n\nReturns a dictionary of input variables with their starting values.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\ndict::Dict{String, Array{fmi2ValueReferenceFormat}}: Returns a dictionary that constructs a hash table with keys of type String and values of type fmi2ValueReferenceFormat. So returns a dict with ( md.modelVariables[i].name::String, starts:: Array{fmi2ValueReferenceFormat} ). (Creates a tuple (name, starts) for each i in inputIndices)\n\nSee also fmi2GetStartValue.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetVersion","page":"Developer Level API","title":"FMICore.fmi2GetVersion","text":"Source: FMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\n\nReturns the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “2.0”\n\n\n\n\n\nfmi2GetVersion(fmu::FMU2)\n\nReturns the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “2.0”\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\nfmi2GetVersion(c::FMU2Component)\n\nReturns the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns a string from the address of a C-style (NUL-terminated) string. The string represents the version of the “fmi2Functions.h” header file which was used to compile the functions of the FMU. The function returns “fmiVersion” which is defined in this header file. The standard header file as documented in this specification has version “2.0”\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetTypesPlatform","page":"Developer Level API","title":"FMICore.fmi2GetTypesPlatform","text":"Source: FMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU. The standard header file, as documented in this specification, has fmi2TypesPlatform set to “default” (so this function usually returns “default”).\n\n\n\n\n\nfmi2GetTypesPlatform(fmu::FMU2)\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU. The standard header file, as documented in this specification, has fmi2TypesPlatform set to “default” (so this function usually returns “default”).\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\nfmi2GetTypesPlatform(c::FMU2Component)\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU. The standard header file, as documented in this specification, has fmi2TypesPlatform set to “default” (so this function usually returns “default”).\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturns the string to uniquely identify the “fmi2TypesPlatform.h” header file used for compilation of the functions of the FMU.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.4 Inquire Platform and Version Number of Header Files\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetSolutionDerivative","page":"Developer Level API","title":"FMIImport.fmi2GetSolutionDerivative","text":"fmi2GetSolutionDerivative(solution::FMU2Solution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the Solution values.\n\nArguments\n\nsolution::FMU2Solution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the spezific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf the length of the given referencees equals 1, each element myt in the collection solution.states.t is selecting the derivative of the solution states represented by indices[1] in respect to time, at time myt and returns its it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected derivatives. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one indice is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Creation,-Destruction-and-Logging-of-FMU-Instances","page":"Developer Level API","title":"Creation, Destruction and Logging of FMU Instances","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"This section documents functions that deal with instantiation, destruction and logging of FMUs.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2Instantiate!\nfmi2FreeInstance!\nfmi2SetDebugLogging\n","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2Instantiate!","page":"Developer Level API","title":"FMIImport.fmi2Instantiate!","text":"fmi2Instantiate!(fmu::FMU2; \n                    instanceName::String=fmu.modelName, \n                    type::fmi2Type=fmu.type, \n                    pushComponents::Bool = true, \n                    visible::Bool = false, \n                    loggingOn::Bool = fmu.executionConfig.loggingOn, \n                    externalCallbacks::Bool = fmu.executionConfig.externalCallbacks,\n                    logStatusOK::Bool=true, \n                    logStatusWarning::Bool=true, \n                    logStatusDiscard::Bool=true, \n                    logStatusError::Bool=true, \n                    logStatusFatal::Bool=true, \n                    logStatusPending::Bool=true)\n\nCreate a new instance of the given fmu, adds a logger if logginOn == true.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nKeywords\n\ninstanceName::String=fmu.modelName: Name of the instance\ntype::fmi2Type=fmu.type: Defines whether a Co-Simulation or Model Exchange is present\npushComponents::Bool = true: Defines if the fmu components should be pushed in the application.\nvisible::Bool = false if the FMU should be started with graphic interface, if supported (default=false)\nloggingOn::Bool = fmu.executionConfig.loggingOn if the FMU should log and display function calls (default=false)\nexternalCallbacks::Bool = fmu.executionConfig.externalCallbacks if an external shared library should be used for the fmi2CallbackFunctions, this may improve readability of logging messages (default=false)\nlogStatusOK::Bool=true whether to log status of kind fmi2OK (default=true)\nlogStatusWarning::Bool=true whether to log status of kind fmi2Warning (default=true)\nlogStatusDiscard::Bool=true whether to log status of kind fmi2Discard (default=true)\nlogStatusError::Bool=true whether to log status of kind fmi2Error (default=true)\nlogStatusFatal::Bool=true whether to log status of kind fmi2Fatal (default=true)\nlogStatusPending::Bool=true whether to log status of kind fmi2Pending (default=true)\n\nReturns\n\nReturns the instance of a new FMU component.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\nSee also fmi2Instantiate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2FreeInstance!","page":"Developer Level API","title":"FMICore.fmi2FreeInstance!","text":"Source: FMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nDisposes the given instance, unloads the loaded model, and frees all the allocated memory and other resources that have been allocated by the functions of the FMU interface. If a null pointer is provided for “c”, the function call is ignored (does not have an effect).\n\nRemoves the component from the FMUs component list.\n\n\n\n\n\nfmi2FreeInstance!(fmu::FMU2)\n\nWrapper for fmi2FreeInstance!() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetDebugLogging","page":"Developer Level API","title":"FMICore.fmi2SetDebugLogging","text":"Source: FMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nThe function controls debug logging that is output via the logger function callback. If loggingOn = fmi2True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi2SetDebugLogging(c::FMU2Component, logginOn::fmi2Boolean, nCategories::Unsigned, categories::Ptr{Nothing})\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nlogginOn::fmi2Boolean: If loggingOn = fmi2True, debug logging is enabled for the log categories specified in categories, otherwise it is disabled. Type fmi2Boolean is defined as an alias Type for the C-Type Boolean and is to be used with fmi2True and fmi2False.\nnCategories::Unsigned: Argument nCategories defines the length of the argument categories.\ncategories::Ptr{Nothing}:\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nSee also fmi2SetDebugLogging.\n\n\n\n\n\nfmi2SetDebugLogging(c::FMU2Component)\n\nControl the use of the logging callback function, version independent.\n\nArguments\n\nc::FMU2Component: Argument c is a mutable struct representing an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.5 Creation, Destruction and Logging of FMU Instances\n\nSee also fmi2SetDebugLogging.\n\n\n\n\n\nfmi2SetDebugLogging(fmu::FMU2)\n\nWrapper for fmi2SetDebugLogging() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Initialization,-Termination,-and-Resetting-an-FMU","page":"Developer Level API","title":"Initialization, Termination, and Resetting an FMU","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"This section documents functions that deal with initialization, termination, resetting of an FMU.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2SetupExperiment\nfmi2EnterInitializationMode\nfmi2ExitInitializationMode\nfmi2Terminate\nfmi2Reset","category":"page"},{"location":"fmi2_library/#FMICore.fmi2SetupExperiment","page":"Developer Level API","title":"FMICore.fmi2SetupExperiment","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to setup the experiment. This function must be called after fmi2Instantiate and before fmi2EnterInitializationMode is called.The function controls debug logging that is output via the logger function callback. If loggingOn = fmi2True, debug logging is enabled, otherwise it is switched off.\n\n\n\n\n\nfmi2SetupExperiment(c::FMU2Component, toleranceDefined::fmi2Boolean, tolerance::fmi2Real, startTime::fmi2Real, stopTimeDefined::fmi2Boolean, stopTime::fmi2Real)\n\nInforms the FMU to setup the experiment. This function must be called after fmi2Instantiate and before fmi2EnterInitializationMode is called.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ntoleranceDefined::fmi2Boolean: Arguments toleranceDefined depend on the FMU type:\nfmuType = fmi2ModelExchange: If toleranceDefined = fmi2True, then the model is called with a numerical integration scheme where the step size is controlled by using tolerance for error estimation. In such a case, all numerical algorithms used inside the model (for example, to solve non-linear algebraic equations) should also operate with an error estimation of an appropriate smaller relative tolerance.\nfmuType = fmi2CoSimulation: If toleranceDefined = fmi2True, then the communication interval of the slave is controlled by error estimation.  In case the slave utilizes a numerical integrator with variable step size and error estimation, it is suggested to use “tolerance” for the error estimation of the internal integrator (usually as relative tolerance). An FMU for Co-Simulation might ignore this argument.\nstartTime::fmi2Real: Argument startTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed initial value of the independent variable and if the independent variable is time, startTime is the starting time of initializaton.\nstopTimeDefined::fmi2Boolean:  If stopTimeDefined = fmi2True, then stopTime is the defined final value of the independent variable and if stopTimeDefined = fmi2False, then no final value\n\nof the independent variable is defined and argument stopTime is meaningless.\n\nstopTime::fmi2Real: Argument stopTime can be used to check whether the model is valid within the given boundaries or to allocate memory which is necessary for storing results. It is the fixed final value of the independent variable and if the independent variable is “time”, stopTime is the stop time of the simulation.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2SetupExperiment.\n\n\n\n\n\nfmi2SetupExperiment(c::FMU2Component, \n                        startTime::Union{Real, Nothing} = nothing, \n                        stopTime::Union{Real, Nothing} = nothing; \n                        tolerance::Union{Real, Nothing} = nothing)\n\nSetup the simulation but without defining all of the parameters.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct representing an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstartTime::Union{Real, Nothing} = nothing: startTime is a real number which sets the value of starting time of the experiment. The default value is set automatically if doing nothing (default = nothing).\nstopTime::Union{Real, Nothing} = nothing: stopTime is a real number which sets the value of ending time of the experiment. The default value is set automatically if doing nothing (default = nothing).\n\nKeywords\n\ntolerance::Union{Real, Nothing} = nothing: tolerance is a real number which sets the value of tolerance range. The default value is set automatically if doing nothing (default = nothing).\n\nReturns\n\nReturns a warning if str.state is not called in fmi2ComponentStateInstantiated.\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetupExperiment.\n\n\n\n\n\nfmi2SetupExperiment(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetupExperiment() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2EnterInitializationMode","page":"Developer Level API","title":"FMICore.fmi2EnterInitializationMode","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <ScalarVariable initial = \"exact\" or \"approx\"> can be set with the “fmi2SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.2.7). Setting other variables is not allowed. Furthermore, fmi2SetupExperiment must be called at least once before calling fmi2EnterInitializationMode, in order that startTime is defined.\n\n\n\n\n\nfmi2EnterInitializationMode(c::FMU2Component)\n\nInforms the FMU to enter Initialization Mode. Before calling this function, all variables with attribute <ScalarVariable initial = \"exact\" or \"approx\"> can be set with the “fmi2SetXXX” functions (the ScalarVariable attributes are defined in the Model Description File, see section 2.2.7). Setting other variables is not allowed. Furthermore, fmi2SetupExperiment must be called at least once before calling fmi2EnterInitializationMode, in order that startTime is defined.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2EnterInitializationMode.\n\n\n\n\n\nfmi2EnterInitializationMode(fmu::FMU2)\n\nWrapper for fmi2EnterInitializationMode() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2ExitInitializationMode","page":"Developer Level API","title":"FMICore.fmi2ExitInitializationMode","text":"Source: FMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU to exit Initialization Mode.\n\n\n\n\n\nfmi2ExitInitializationMode(c::FMU2Component)\n\nInforms the FMU to exit Initialization Mode.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2EnterInitializationMode.\n\n\n\n\n\nfmi2ExitInitializationMode(fmu::FMU2)\n\nWrapper for fmi2ExitInitializationMode() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2Terminate","page":"Developer Level API","title":"FMICore.fmi2Terminate","text":"Source: FMISpec2.0.2[p.24]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nInforms the FMU that the simulation run is terminated.\n\n\n\n\n\nfmi2Terminate(c::FMU2Component; soft::Bool=false)\n\nInforms the FMU that the simulation run is terminated.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.22]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2Terminate.\n\n\n\n\n\nfmi2Terminate(fmu::FMU2)\n\nWrapper for fmi2Terminate() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2Reset","page":"Developer Level API","title":"FMICore.fmi2Reset","text":"Source: FMISpec2.0.2[p.24]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi2Instantiate would have been called.\n\n\n\n\n\nfmi2Reset(c::FMU2Component; soft::Bool=false)\n\nIs called by the environment to reset the FMU after a simulation run. The FMU goes into the same state as if fmi2Instantiate would have been called.All variables have their default values. Before starting a new run, fmi2SetupExperiment and fmi2EnterInitializationMode have to be called.\n\nArguments\n\nc::FMU2Component: Argument c is a Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.3[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.3[p.22]: 2.1.6 Initialization, Termination, and Resetting an FMU\n\nSee also fmi2Terminate.\n\n\n\n\n\nfmi2Reset(fmu::FMU2)\n\nWrapper for fmi2Reset() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Getting-and-Setting-Variable-Values","page":"Developer Level API","title":"Getting and Setting Variable Values","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"All variable values of an FMU are identified with a variable handle called “value reference”. The handle is defined in the modelDescription.xml file (as attribute “valueReference” in element “ScalarVariable”). Element “valueReference” might not be unique for all variables. If two or more variables of the same base data type (such as fmi2Real) have the same valueReference, then they have identical values but other parts of the variable definition might be different [(for example, min/max attributes)].","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2Get\nfmi2Get!\nfmi2Set\nfmi2GetReal\nfmi2GetReal!\nfmi2GetInteger\nfmi2GetInteger!\nfmi2GetBoolean\nfmi2GetBoolean!\nfmi2GetString\nfmi2GetString!\nfmi2SetReal\nfmi2SetInteger\nfmi2SetBoolean\nfmi2SetString","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2Get","page":"Developer Level API","title":"FMIImport.fmi2Get","text":"fmi2Get(comp::FMU2Component, vrs::fmi2ValueReferenceFormat)\n\nReturns the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference in an array.\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\ndstArray::Array{Any,1}(undef, length(vrs)): Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). dstArray is a 1-Dimensional Array that has the same length as vrs.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\n\n\n\n\nfmiGet(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmiGet() in FMIImport/FMI2_ext.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2Get!","page":"Developer Level API","title":"FMIImport.fmi2Get!","text":"fmi2Get!(comp::FMU2Component, vrs::fmi2ValueReferenceFormat, dstArray::AbstractArray)\n\nStores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference and returns an array that indicates the Status.\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\ndstArray::AbstractArray: Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). dstArray has the same length as vrs.\n\nReturns\n\nretcodes::Array{fmi2Status}: Returns an array of length length(vrs) with Type fmi2Status. Type fmi2Status is an enumeration and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\n\n\n\n\nfmiGet!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmiGet!() in FMIImport/FMI2_ext.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2Set","page":"Developer Level API","title":"FMIImport.fmi2Set","text":"fmi2Set(comp::FMU2Component, \n            vrs::fmi2ValueReferenceFormat, \n            srcArray::AbstractArray; \n            filter=nothing)\n\nStores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference and returns an array that indicates the Status.\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nsrcArray::AbstractArray: Stores the specific value of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr (vr = vrs[i]). srcArray has the same length as vrs.\n\nKeywords\n\nfilter=nothing: It is applied to each ModelVariable to determine if it should be updated.\n\nReturns\n\nretcodes::Array{fmi2Status}: Returns an array of length length(vrs) with Type fmi2Status. Type fmi2Status is an enumeration and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.23]: 2.1.6 Initialization, Termination, and Resetting an FMU\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\n\n\n\n\nfmiSet(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmiSet() in FMIImport/FMI2_ext.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetReal","page":"Developer Level API","title":"FMIImport.fmi2GetReal","text":"fmi2GetReal(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2Real variables.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fm2Real}: Returns values of an array of fmi2Real variables with the dimension of fmi2ValueReferenceFormat length.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal.\n\n\n\n\n\nfmi2GetReal(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetReal() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetReal!","page":"Developer Level API","title":"FMICore.fmi2GetReal!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetReal!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Real})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetReal!.\n\n\n\n\n\nfmi2GetReal!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Real})\n\nGet the values of an array of fmi2Real variables.\n\nrites the real values of an array of variables in the given field\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetReal!.\n\n\n\n\n\nfmi2GetReal!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetReal!() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetInteger","page":"Developer Level API","title":"FMIImport.fmi2GetInteger","text":"fmi2GetInteger(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nReturns the integer values of an array of variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Integer}: Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!\n\n\n\n\n\nfmi2GetInteger(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetInteger() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetInteger!","page":"Developer Level API","title":"FMICore.fmi2GetInteger!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetInteger!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Integer})\n\nWrites the integer values of an array of variables in the given field\n\nfmi2GetInteger! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Integer}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\nfmi2GetInteger!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Integer})\n\nWrites the integer values of an array of variables in the given field\n\nfmi2GetInteger! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::Array{fmi2Integer}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\nfmi2GetInteger!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetInteger!() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetBoolean","page":"Developer Level API","title":"FMIImport.fmi2GetBoolean","text":"fmi2GetBoolean(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2Boolean variables.\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2Boolean}: Return values is an array with the actual values of these variables.\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\nfmi2GetBoolean(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetBoolean() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetBoolean!","page":"Developer Level API","title":"FMICore.fmi2GetBoolean!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetBoolean!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi2GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi2Boolean}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\nfmi2GetBoolean!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2Boolean})\n\nWrites the boolean values of an array of variables in the given field\n\nfmi2GetBoolean! is only possible for arrays of values, please use an array instead of a scalar.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Boolean}: Argument value is an array with the actual values of these variables\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\nfmi2GetBoolean!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetBoolean!() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetString","page":"Developer Level API","title":"FMIImport.fmi2GetString","text":"fmi2GetString(c::FMU2Component, vr::fmi2ValueReferenceFormat)\n\nGet the values of an array of fmi2String variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nvalues::Array{fmi2String}:  Return values is an array with the actual values of these variables.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2GetString(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetString() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetString!","page":"Developer Level API","title":"FMICore.fmi2GetString!","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2GetString!(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::Union{AbstractArray{Ptr{Cchar}}, AbstractArray{Ptr{UInt8}}})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nThese functions are especially used to get the actual values of output variables if a model is connected with other models.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::Union{AbstractArray{Ptr{Cchar}, AbstractArray{Ptr{UInt8}}}: The value argument is an AbstractArray of values whose memory address refers to data of type Cchar or UInt8and describes a vector with the actual values of these. variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2GetString!(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::AbstractArray{fmi2String})\n\nWrites the string values of an array of variables in the given field\n\nThese functions are especially used to get the actual values of output variables if a model is connected with other models.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::AbstractArray{fmi2String}: Argument values is an AbstractArray with the actual values of these variables\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2GetString!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetString!() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetReal","page":"Developer Level API","title":"FMICore.fmi2SetReal","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetReal(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Real})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fm2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetReal.\n\n\n\n\n\nfmi2SetReal(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{<:Real}, <:Real})\n\nSet the values of an array of real variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Wildcards for how a user can pass a fmi[X]ValueReference\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{<:Real}, <:Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetReal.\n\n\n\n\n\nfmi2SetReal(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetReal() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetInteger","page":"Developer Level API","title":"FMICore.fmi2SetInteger","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetInteger(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Integer})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an AbstractArray of nvr value handels, called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalues::AbstractArray{fmi2Integer}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetInteger!.\n\n\n\n\n\nfmi2SetInteger(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{<:Integer}, <:Integer})\n\nSet the values of an array of integer variables\n\nArguments\n\nc::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nc::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nvalues::Union{Array{<:Integer}, <:Integer}: Argument values is an array or a single value with type Integer or any subtyp\n\nReturns\n\nstatus::fmi2Status: Return status indicates the success of the function call.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2SetInteger.\n\n\n\n\n\nfmi2SetInteger(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetInteger() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetBoolean","page":"Developer Level API","title":"FMICore.fmi2SetBoolean","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetBoolean(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::AbstractArray{fmi2Boolean})\n\nFunctions to get and set values of variables idetified by their valueReference\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::AbstractArray{fmi2Boolean}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean.\n\n\n\n\n\nfmi2SetBoolean(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{Bool}, Bool})\n\nSet the values of an array of boolean variables\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{Bool}, Bool}: Argument values is an array or a single value with type Boolean or any subtyp\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\n\nSee also fmi2GetBoolean!.\n\n\n\n\n\nfmi2SetBoolean(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetBoolean() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetString","page":"Developer Level API","title":"FMICore.fmi2SetString","text":"Source: FMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nFunctions to get and set values of variables idetified by their valueReference\n\n\n\n\n\nfmi2SetString(c::FMU2Component, vr::AbstractArray{fmi2ValueReference}, nvr::Csize_t, value::Union{AbstractArray{Ptr{Cchar}}, AbstractArray{Ptr{UInt8}}})\n\nSet the values of an array of string variables\n\nFor the exact rules on which type of variables fmi2SetXXX can be called see FMISpec2.0.2 section 2.2.7 , as well as FMISpec2.0.2 section 3.2.3 in case of ModelExchange and FMISpec2.0.2 section 4.2.4 in case ofCoSimulation.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::AbstractArray{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variable that shall be inquired.\nnvr::Csize_t: Argument nvr defines the size of vr.\nvalue::Union{AbstractArray{Ptr{Cchar}, AbstractArray{Ptr{UInt8}}}: The value argument is an AbstractArray of values whose memory address refers to data of type Cchar or UInt8and describes a vector with the actual values of these. variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetString!.\n\n\n\n\n\nfmi2SetString(c::FMU2Component, vr::fmi2ValueReferenceFormat, values::Union{AbstractArray{String}, String})\n\nSet the values of an array of string variables\n\nFor the exact rules on which type of variables fmi2SetXXX can be called see FMISpec2.0.2 section 2.2.7 , as well as FMISpec2.0.2 section 3.2.3 in case of ModelExchange and FMISpec2.0.2 section 4.2.4 in case of CoSimulation.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::fmi2ValueReferenceFormat: Argument vr defines the value references of the variables.\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nvalues::Union{Array{String}, String}: Argument values is an array or a single value with type String.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\nFMISpec2.0.2[p.46]: 2.2.7 Definition of Model Variables\nFMISpec2.0.2[p.46]: 3.2.3 State Machine of Calling Sequence\nFMISpec2.0.2[p.108]: 4.2.4 State Machine of Calling Sequence from Master to Slave\n\nSee also fmi2SetString.\n\n\n\n\n\nfmi2SetString(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetString() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Getting-and-Setting-the-Complete-FMU-State","page":"Developer Level API","title":"Getting and Setting the Complete FMU State","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"The FMU has an internal state consisting of all values that are needed to continue a simulation. This internal state consists especially of the values of the continuous-time states, iteration variables, parameter values, input values, delay buffers, file identifiers, and FMU internal status information. With the functions of this section, the internal FMU state can be copied and the pointer to this copy is returned to the environment. The FMU state copy can be set as actual FMU state, in order to continue the simulation from it.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2GetFMUstate\nfmi2GetFMUstate!\nfmi2SetFMUstate\nfmi2FreeFMUstate!\nfmi2SerializedFMUstateSize\nfmi2SerializedFMUstateSize!\nfmi2SerializeFMUstate\nfmi2SerializeFMUstate!\nfmi2DeSerializeFMUstate\nfmi2DeSerializeFMUstate!","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2GetFMUstate","page":"Developer Level API","title":"FMIImport.fmi2GetFMUstate","text":"fmi2GetFMUstate(c::FMU2Component)\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate.\n\n\n\n\n\nfmi2GetFMUstate(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetFMUstate() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetFMUstate!","page":"Developer Level API","title":"FMICore.fmi2GetFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2GetFMUstate makes a copy of the internal FMU state and returns a pointer to this copy\n\n\n\n\n\nfmi2GetFMUstate!(c::FMU2Component, FMUstate::Ref{fmi2FMUstate})\n\nMakes a copy of the internal FMU state and returns a pointer to this copy.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::Ref{fmi2FMUstate}:If on entry FMUstate == NULL, a new allocation is required. If FMUstate != NULL, then FMUstate points to a previously returned FMUstate that has not been modified since.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.24]: 2.1.7 Getting and Setting Variable Values\n\nSee also fmi2GetFMUstate!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetFMUstate","page":"Developer Level API","title":"FMICore.fmi2SetFMUstate","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SetFMUstate copies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\n\n\n\n\nfmi2SetFMUstate(c::FMU2Component, FMUstate::fmi2FMUstate)\n\nCopies the content of the previously copied FMUstate back and uses it as actual new FMU state.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::fmi2FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2GetFMUstate.\n\n\n\n\n\nfmi2SetFMUstate(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetFMUstate() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2FreeFMUstate!","page":"Developer Level API","title":"FMICore.fmi2FreeFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2FreeFMUstate frees all memory and other resources allocated with the fmi2GetFMUstate call for this FMUstate.\n\n\n\n\n\nfmi2FreeFMUstate!(c::FMU2Component, FMUstate::Ref{fmi2FMUstate})\n\nFrees all memory and other resources allocated with the fmi2GetFMUstate call for this FMUstate.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::Ref{fmi2FMUstate}: Argument FMUstate is an object that safely references data of type fmi3FMUstate which is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2FreeFMUstate!.\n\n\n\n\n\nfmi2FreeFMUstate!(c::FMU2Component, state::fmi2FMUstate)\n\nFree the memory for the allocated FMU state\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn singleton instance of type Nothing, if there is no value to return (as in a C void function) or when a variable or field holds no value.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2FreeFMUstate!.\n\n\n\n\n\nfmi2FreeFMUstate!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2FreeFMUstate!() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2SerializedFMUstateSize","page":"Developer Level API","title":"FMIImport.fmi2SerializedFMUstateSize","text":"fmi2SerializedFMUstateSize(c::FMU2Component, state::fmi2FMUstate)\n\nReturns the size of the byte vector in which the FMUstate can be stored.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nReturn size is an object that safely references a value of type Csize_t.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializedFMUstateSize.\n\n\n\n\n\nfmi2SerializedFMUstateSize(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SerializedFMUstateSize() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SerializedFMUstateSize!","page":"Developer Level API","title":"FMICore.fmi2SerializedFMUstateSize!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SerializedFMUstateSize returns the size of the byte vector, in order that FMUstate can be stored in it.\n\n\n\n\n\nfmi2SerializedFMUstateSize!(c::FMU2Component, FMUstate::fmi2FMUstate, size::Ref{Csize_t})\n\nStores the size of the byte vector in the given referenced Address, in order that FMUstate can be stored in it.\n\nArgument\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nFMUstate::fmi2FMUstate: Argument FMUstate is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nsize::Ref{Csize_t}: Argument size is an object that safely references a value of type Csize_t and defines the size of the byte vector in which the FMUstate can be stored.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializedFMUstateSize!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2SerializeFMUstate","page":"Developer Level API","title":"FMIImport.fmi2SerializeFMUstate","text":"fmi2SerializeFMUstate(c::FMU2Component, state::fmi2FMUstate)\n\nSerializes the data referenced by the pointer FMUstate and copies this data into the byte vector serializedState of length size to be provided by the environment.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nserializedState:: Array{fmi2Byte}: Return serializedState contains the copy of the serialized data referenced by the pointer FMUstate\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializeFMUstate.\n\n\n\n\n\nfmi2SerializeFMUstate(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SerializeFMUstate() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SerializeFMUstate!","page":"Developer Level API","title":"FMICore.fmi2SerializeFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2SerializeFMUstate serializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size\n\n\n\n\n\nfmi2SerializeFMUstate!(c::FMU2Component, FMUstate::fmi2FMUstate, serialzedState::AbstractArray{fmi2Byte}, size::Csize_t)\n\nSerializes the data which is referenced by pointer FMUstate and copies this data in to the byte vector serializedState of length size, that must be provided by the environment.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi2Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Csize_t: Argument size defines the length of the serialized vector.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2SerializeFMUstate.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2DeSerializeFMUstate","page":"Developer Level API","title":"FMIImport.fmi2DeSerializeFMUstate","text":"fmi2DeSerializeFMUstate(c::FMU2Component, serializedState::AbstractArray{fmi2Byte})\n\nDeserialize the data in the serializedState fmi2Byte field\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nserializedState::Array{fmi2Byte}: Argument serializedState contains the fmi2Byte field to be deserialized.\n\nReturns\n\nReturn state is a pointer to a copy of the internal FMU state.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2DeSerializeFMUstate.\n\n\n\n\n\nfmi2DeSerializeFMUstate(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2DeSerializeFMUstate() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2DeSerializeFMUstate!","page":"Developer Level API","title":"FMICore.fmi2DeSerializeFMUstate!","text":"Source: FMISpec2.0.2[p.26]: 2.1.8 Getting and Setting the Complete FMU State\n\nfmi2DeSerializeFMUstate deserializes the byte vector serializedState of length size, constructs a copy of the FMU state and returns FMUstate, the pointer to this copy.\n\n\n\n\n\nfmi2DeSerializeFMUstate!(c::FMU2Component, serializedState::AbstractArray{fmi2Byte}, size::Csize_t, FMUstate::Ref{fmi2FMUstate})\n\nDeserializes the byte vector serializedState of length size, constructs a copy of the FMU state and stores the FMU state in the given address of the reference FMUstate, the pointer to this copy.\n\nArguments\n\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nstate::fmi2FMUstate: Argument state is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\nserialzedState::AbstractArray{fmi2Byte}: Argument serializedState contains the copy of the serialized data referenced by the pointer FMUstate.\nsize::Csize_t: Argument size defines the length of the serialized vector.\nFMUstate::Ref{fmi2FMUstate}: Argument FMUstate is an object that safely references data of type fmi3FMUstate which is a pointer to a data structure in the FMU that saves the internal FMU state of the actual or a previous time instant.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.8 Getting and Setting the Complete FMU State\n\nSee also fmi2DeSerializeFMUstate!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Getting-Partial-Dervatives","page":"Developer Level API","title":"Getting Partial Dervatives","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"It is optionally possible to provide evaluation of partial derivatives for an FMU. For Model Exchange, this means computing the partial derivatives at a particular time instant. For Co-Simulation, this means to compute the partial derivatives at a particular communication point. One function is provided to compute directional derivatives. This function can be used to construct the desired partial derivative matrices.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2GetDirectionalDerivative!\nfmi2SetRealInputDerivatives\nfmi2GetRealOutputDerivatives!\nfmi2SampleJacobian\nfmi2SampleJacobian!","category":"page"},{"location":"fmi2_library/#FMICore.fmi2GetDirectionalDerivative!","page":"Developer Level API","title":"FMICore.fmi2GetDirectionalDerivative!","text":"Source: FMISpec2.0.2[p.26]: 2.1.9 Getting Partial Derivatives\n\nThis function computes the directional derivatives of an FMU.\n\nΔvUnknown = ∂h / ∂vKnown ⋅ ΔvKnown\n\n\n\n\n\nfmi2GetDirectionalDerivative!(c::FMU2Component,\n                                   vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                   nUnknown::Csize_t,\n                                   vKnown_ref::AbstractArray{fmi2ValueReference},\n                                   nKnown::Csize_t,\n                                   dvKnown::AbstractArray{fmi2Real},\n                                   dvUnknown::AbstractArray{fmi2Real})\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯unknown = 𝐡(𝐯known, 𝐯_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔvunknown = (δh / δvknown) Δv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstracArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nnUnknown::Csize_t: Length of the Unknown Array.\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\nnKnown::Csize_t: Length of the Known Array.\ndvKnown::AbstractArray{fmi2Real}:The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.\ndvUnknown::AbstractArray{fmi2Real}: Stores the directional derivative vector values.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\nfmiGetDirectionalDerivative!(c::FMU2Component,\n                                  vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                  vKnown_ref::AbstractArray{fmi2ValueReference},\n                                  dvUnknown::AbstractArray,\n                                  dvKnown::Union{Array{fmi2Real}, Nothing} = nothing)\n\nWrapper Function call to compute the partial derivative with respect to the variables vKnown_ref.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns.The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯unknown = 𝐡(𝐯known, 𝐯_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔv_unknown = (δh / δv_known) Δv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstracArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\ndvUnknown::AbstractArray{fmi2Real}: Stores the directional derivative vector values.\ndvKnown::Union{AbstractArray{fmi2Real}, Nothing} = nothing: If no seed vector is passed the value nothing is used. The vector values Compute the partial derivative with respect to the given entries in vector vKnown_ref with the matching evaluate of dvKnown.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.25]: 2.1.9 Getting Partial Derivatives\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\nfmi2GetDirectionalDerivative!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetDirectionalDerivative!() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetRealInputDerivatives","page":"Developer Level API","title":"FMICore.fmi2SetRealInputDerivatives","text":"Source: FMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSets the n-th time derivative of real input variables. vr defines the value references of the variables the array order specifies the corresponding order of derivation of the variables\n\n\n\n\n\nfmi2SetRealInputDerivatives(c::FMU2Component,\n                                vr::AbstractArray{fmi2ValueReference},\n                                nvr::Csize_t,\n                                order::AbstractArray{fmi2Integer}, \n                                value::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnvr::Csize_t: Argument nvr defines the size of vr.\norder::AbstractArray{fmi2Integer}: Argument order is an AbstractArray of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::AbstractArray{fmi2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSee also fmi2SetRealInputDerivatives.\n\n\n\n\n\nfmi2SetRealInputDerivatives(c::FMU2Component, \n                                vr::AbstractArray{fmi2ValueReference}, \n                                order::AbstractArray{fmi2Integer}, \n                                values::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that define the variables whose derivatives shall be set.\norder::AbstractArray{fmi2Integer}: Argument order is an AbstractArray of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::AbstractArray{fmi2Real}: Argument values is an AbstractArray with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nSee also fmi2SetRealInputDerivatives.\n\n\n\n\n\nfmi2SetRealInputDerivatives(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetRealInputDerivatives() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetRealOutputDerivatives!","page":"Developer Level API","title":"FMICore.fmi2GetRealOutputDerivatives!","text":"Source: FMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\nRetrieves the n-th derivative of output values. vr defines the value references of the variables the array order specifies the corresponding order of derivation of the variables\n\n\n\n\n\nfmi2GetRealOutputDerivatives!(c::FMU2Component,  \n                                vr::AbstractArray{fmi2ValueReference}, \n                                nvr::Csize_t, order::AbstractArray{fmi2Integer}, \n                                value::AbstractArray{fmi2Real})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\nnvr::Csize_t: Argument nvr defines the size of vr.\norder::Array{fmi2Integer}: Argument order is an array of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\nvalues::Array{fmi2Real}: Argument values is an array with the actual values of these variables.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2SampleJacobian","page":"Developer Level API","title":"FMIImport.fmi2SampleJacobian","text":"fmi2SampleJacobian(c::FMU2Component,\n                        vUnknown_ref::AbstractArray{fmi2ValueReference},\n                        vKnown_ref::AbstractArray{fmi2ValueReference},\n                        steps::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nThis function samples the directional derivative by manipulating corresponding values (central differences).\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯unknown = 𝐡(𝐯known, 𝐯_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes.\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔvunknown = (δh / δvknown) Δv_known\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\nsteps::Union{AbstractArray{fmi2Real}, Nothing} = nothing): If sampling is used, sampling step size can be set (for each direction individually) using optional argument steps.\n\nReturns\n\ndvUnkonwn::Array{fmi2Real}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(see function fmi2GetDirectionalDerivative!).\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\nfmi2SampleJacobian(c::FMU2Component,\n                        vUnknown_ref::Array{fmi2ValueReference},\n                        vKnown_ref::Array{fmi2ValueReference},\n                        steps::Array{fmi2Real} = ones(fmi2Real, length(vKnown_ref)).*1e-5)\n\nThis function samples the directional derivative by manipulating corresponding values (central differences).\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::Array{fmi2ValueReference}:  Argument vUnKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref is the Array of the vector values of Real input variables of function h that changes its value in the actual Mode.\nvKnown_ref::Array{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref is the Array of the vector values of Real input variables of function h that changes its value in the actual Mode.\nsteps::Array{fmi2Real} = ones(fmi2Real, length(vKnown_ref)).*1e-5: Predefined step size vector steps, where all entries have the value 1e-5.\n\nReturns\n\ndvUnknown::Arrya{fmi2Real}: stores the samples of the directional derivative\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2SampleJacobian!","page":"Developer Level API","title":"FMIImport.fmi2SampleJacobian!","text":"function fmi2SampleJacobian!(mtx::Matrix{<:Real},\n                                c::FMU2Component,\n                                vUnknown_ref::AbstractArray{fmi2ValueReference},\n                                vKnown_ref::AbstractArray{fmi2ValueReference},\n                                steps::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nThis function samples the directional derivative by manipulating corresponding values (central differences) and saves in-place.\n\nComputes the directional derivatives of an FMU. An FMU has different Modes and in every Mode an FMU might be described by different equations and different unknowns. The precise definitions are given in the mathematical descriptions of Model Exchange (section 3.1) and Co-Simulation (section 4.1). In every Mode, the general form of the FMU equations are: 𝐯unknown = 𝐡(𝐯known, 𝐯_rest)\n\nv_unknown: vector of unknown Real variables computed in the actual Mode:\nInitialization Mode: unkowns kisted under <ModelStructure><InitialUnknowns> that have type Real.\nContinuous-Time Mode (ModelExchange): The continuous-time outputs and state derivatives. (= the variables listed under <ModelStructure><Outputs> with type Real and variability = continuous and the variables listed as state derivatives under <ModelStructure><Derivatives>).\nEvent Mode (ModelExchange): The same variables as in the Continuous-Time Mode and additionally variables under <ModelStructure><Outputs> with type Real and variability = discrete.\nStep Mode (CoSimulation):  The variables listed under <ModelStructure><Outputs> with type Real and variability = continuous or discrete. If <ModelStructure><Derivatives> is present, also the variables listed here as state derivatives.\nv_known: Real input variables of function h that changes its value in the actual Mode.\nv_rest:Set of input variables of function h that either changes its value in the actual Mode but are non-Real variables, or do not change their values in this Mode, but change their values in other Modes\n\nComputes a linear combination of the partial derivatives of h with respect to the selected input variables 𝐯_known:\n\nΔvunknown = (δh / δvknown) Δv_known\n\nArguments\n\nmtx::Matrix{<:Real}:Output matrix to store the Jacobian. Its dimensions must be compatible with the number of unknown and known value references.\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model. vUnknown_ref can be equated with v_unknown(variable described above).\nvKnown_ref::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref can be equated with v_known(variable described above).\ndvUnknown::AbstractArray{fmi2Real}: Stores the directional derivative vector values.\nsteps::Union{AbstractArray{fmi2Real}, Nothing} = nothing): Step size to be used for numerical differentiation. If nothing, a default value will be chosen automatically.\n\nReturns\n\nnothing\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\nSee also fmi2GetDirectionalDerivative!.\n\n\n\n\n\nfmi2SampleJacobian!(c::FMU2Component,\n                        vUnknown_ref::Array{fmi2ValueReference},\n                        vKnown_ref::Array{fmi2ValueReference},\n                        dvUnknown::AbstractArray,\n                        steps::Array{fmi2Real} = ones(fmi2Real, length(vKnown_ref)).*1e-5)\n\nThis function samples the directional derivative by manipulating corresponding values (central differences) and saves in-place.\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvUnknown_ref::Array{fmi2ValueReference}:  Argument vUnKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref is the Array of the vector values of Real input variables of function h that changes its value in the actual Mode.\nvKnown_ref::Array{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.vKnown_ref is the Array of the vector values of Real input variables of function h that changes its value in the actual Mode.\ndvUnknown::AbstractArray: stores the samples of the directional derivative\nsteps::Array{fmi2Real} = ones(fmi2Real, length(vKnown_ref)).*1e-5: current time stepsize\n\nReturns\n\nnothing\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMI-for-Model-Exchange","page":"Developer Level API","title":"FMI for Model Exchange","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"This chapter contains the interface description to access the equations of a dynamic system from a C program.","category":"page"},{"location":"fmi2_library/#Providing-Independent-Variables-and-Re-initialization-of-Caching","page":"Developer Level API","title":"Providing Independent Variables and Re-initialization of Caching","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"Depending on the situation, different variables need to be computed. In order to be efficient, it is important that the interface requires only the computation of variables that are needed in the present context. The state derivatives shall be reused from the previous call. This feature is called “caching of variables” in the sequel. Caching requires that the model evaluation can detect when the input arguments, like time or states, have changed.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2SetTime\nfmi2SetContinuousStates","category":"page"},{"location":"fmi2_library/#FMICore.fmi2SetTime","page":"Developer Level API","title":"FMICore.fmi2SetTime","text":"Source: FMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\n\n\n\n\nfmi2SetTime(c::FMU2Component, \n                time::fmi2Real; \n                soft::Bool=false,\n                track::Bool=true,\n                force::Bool=c.fmu.executionConfig.force,\n                time_shift::Bool=c.fmu.executionConfig.autoTimeShift)\n\nSet a new time instant and re-initialize caching of variables that depend on time, provided the newly provided time value is different to the previously set time value (variables that depend solely on constants or parameters need not to be newly computed in the sequel, but the previously computed values can be reused).\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ntime::fmi2Real: Argument time contains a value of type fmi2Real which is a alias type for Real data type. time sets the independent variable time t.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\n-track::Bool=true: If the Keyword track = true\n\ntime_shift::Bool=c.fmu.executionConfig.autoTimeShift:\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetTime.\n\n\n\n\n\nfmiSetTime(c::FMU2Component, t::Real)\n\nSet a new time instant and re-initialize caching of variables that depend on time.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nt::Real: Argument t contains a value of type Real. t sets the independent variable time t.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetTime\n\n\n\n\n\nfmi2SetTime(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetTime() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2SetContinuousStates","page":"Developer Level API","title":"FMICore.fmi2SetContinuousStates","text":"Source: FMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSet a new (continuous) state vector and re-initialize caching of variables that depend on the states. Argument nx is the length of vector x and is provided for checking purposes\n\n\n\n\n\nfmiSetContinuousStates(c::FMU2Component,\n                             x::Union{AbstractArray{Float32},AbstractArray{Float64}})\n\nSet a new (continuous) state vector and reinitialize chaching of variables that depend on states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::Union{AbstractArray{Float32},AbstractArray{Float64}}:Argument x is the AbstractArray of the vector values of Float64 or Float32.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.1 Providing Independent Variables and Re-initialization of Caching\n\nSee also fmi2SetContinuousStates.\n\n\n\n\n\nfmi2SetContinuousStates(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2SetContinuousStates() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Evaluation-of-Model-Equations","page":"Developer Level API","title":"Evaluation of Model Equations","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"This section contains the core functions to evaluate the model equations.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2EnterEventMode\nfmi2NewDiscreteStates\nfmi2NewDiscreteStates!\nfmi2EnterContinuousTimeMode\nfmi2CompletedIntegratorStep\nfmi2CompletedIntegratorStep!\nfmi2GetDerivatives\nfmi2GetDerivatives!\nfmi2GetEventIndicators\nfmi2GetEventIndicators!\nfmi2GetContinuousStates\nfmi2GetContinuousStates!\nfmi2GetNominalsOfContinuousStates\nfmi2GetNominalsOfContinuousStates!","category":"page"},{"location":"fmi2_library/#FMICore.fmi2EnterEventMode","page":"Developer Level API","title":"FMICore.fmi2EnterEventMode","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nThe model enters Event Mode from the Continuous-Time Mode and discrete-time equations may become active (and relations are not “frozen”).\n\n\n\n\n\nfmi2EnterEventMode(c::FMU2Component; soft::Bool=false)\n\nThe model enters Event Mode from the Continuous-Time Mode and discrete-time equations may become active (and relations are not “frozen”).\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterEventMode.\n\n\n\n\n\nfmi2EnterEventMode(fmu::FMU2)\n\nWrapper for fmi2EnterEventMode() in FMIImport/FMI2_c.jl\n\n\n\n\n\nfmi2EnterEventMode(str::fmi2Struct)\n\nThe model enters Event Mode from the Continuous-Time Mode and discrete-time equations may become active (and relations are not “frozen”).\n\nArguments\n\nstr::fmi2Struct:  Representative for an FMU in the FMI 2.0.2 Standard.\n\nMore detailed: fmi2Struct = Union{FMU2, FMU2Component}\n\nstr::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nstr::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterEventMode.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2NewDiscreteStates","page":"Developer Level API","title":"FMIImport.fmi2NewDiscreteStates","text":"fmi2NewDiscreteStates(c::FMU2Component)\n\nReturns the next discrete states\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventInfo::fmi2EventInfo*: Strut with fmi2Boolean Variables\n\nMore detailed:\n\nnewDiscreteStatesNeeded::fmi2Boolean: If newDiscreteStatesNeeded = fmi2True the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU to compute and get the outputs and to call\n\nfmi2NewDiscreteStates again. If all FMUs return newDiscreteStatesNeeded = fmi2False call fmi2EnterContinuousTimeMode.\n\nterminateSimulation::fmi2Boolean: If terminateSimulation = fmi2True call fmi2Terminate\nnominalsOfContinuousStatesChanged::fmi2Boolean: If nominalsOfContinuousStatesChanged = fmi2True then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates.\nvaluesOfContinuousStatesChanged::fmi2Boolean: If valuesOfContinuousStatesChanged = fmi2True, then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False.\nnextEventTimeDefined::fmi2Boolean: If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, the definition of nextEventTime becomes obsolete.\nnextEventTime::fmi2Real: next event if nextEventTimeDefined=fmi2True\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2NewDiscreteStates.\n\n\n\n\n\nfmi2NewDiscreteStates(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2NewDiscreteStates() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2NewDiscreteStates!","page":"Developer Level API","title":"FMICore.fmi2NewDiscreteStates!","text":"Source: FMISpec2.0.2[p.84]: 3.2.2 Evaluation of Model Equations\n\nThe FMU is in Event Mode and the super dense time is incremented by this call.\n\n\n\n\n\nfmi2NewDiscreteStates!(c::FMU2Component, eventInfo::fmi2EventInfo)\n\nThe FMU is in Event Mode and the super dense time is incremented by this call.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventInfo::fmi2EventInfo*: Strut with fmi2Boolean Variables that\n\nMore detailed:\n\nnewDiscreteStatesNeeded::fmi2Boolean: If newDiscreteStatesNeeded = fmi2True the FMU should stay in Event Mode, and the FMU requires to set new inputs to the FMU to compute and get the outputs and to call\n\nfmi2NewDiscreteStates again. If all FMUs return newDiscreteStatesNeeded = fmi2False call fmi2EnterContinuousTimeMode.\n\nterminateSimulation::fmi2Boolean: If terminateSimulation = fmi2True call fmi2Terminate\nnominalsOfContinuousStatesChanged::fmi2Boolean: If nominalsOfContinuousStatesChanged = fmi2True then the nominal values of the states have changed due to the function call and can be inquired with fmi2GetNominalsOfContinuousStates.\nvaluesOfContinuousStatesChanged::fmi2Boolean: If valuesOfContinuousStatesChanged = fmi2True, then at least one element of the continuous state vector has changed its value due to the function call. The new values of the states can be retrieved with fmi2GetContinuousStates. If no element of the continuous state vector has changed its value, valuesOfContinuousStatesChanged must return fmi2False.\nnextEventTimeDefined::fmi2Boolean: If nextEventTimeDefined = fmi2True, then the simulation shall integrate at most until time = nextEventTime, and shall call fmi2EnterEventMode at this time instant. If integration is stopped before nextEventTime, the definition of nextEventTime becomes obsolete.\nnextEventTime::fmi2Real: next event if nextEventTimeDefined=fmi2True\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2NewDiscreteStates.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2EnterContinuousTimeMode","page":"Developer Level API","title":"FMICore.fmi2EnterContinuousTimeMode","text":"Source: FMISpec2.0.2[p.85]: 3.2.2 Evaluation of Model Equations\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\n\n\n\n\nfmi2EnterContinuousTimeMode(c::FMU2Component; soft::Bool=false)\n\nThe model enters Continuous-Time Mode and all discrete-time equations become inactive and all relations are “frozen”. This function has to be called when changing from Event Mode (after the global event iteration in Event Mode over all involved FMUs and other models has converged) into Continuous-Time Mode.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nKeywords\n\nsoft::Bool=false: If the Keyword soft = true the command is only performed if the FMU is in an allowed state for this command.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2EnterContinuousTimeMode.\n\n\n\n\n\nfmi2EnterContinuousTimeMode(fmu::FMU2)\n\nWrapper for fmi2EnterContinuousTimeMode() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2CompletedIntegratorStep","page":"Developer Level API","title":"FMIImport.fmi2CompletedIntegratorStep","text":"fmiCompletedIntegratorStep(c::FMU2Component, noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nThis function must be called by the environment after every completed step\n\nArguments\n\nC::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi2True if fmi2SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\nenterEventMode::Array{fmi2Boolean, 1}: Returns enterEventMode[1] to signal to the environment if the FMU shall call fmi2EnterEventMode\nterminateSimulation::Array{fmi2Boolean, 1}: Returns terminateSimulation[1] to signal if the simulation shall be terminated.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2CompletedIntegratorStep.\n\n\n\n\n\nfmi2CompletedIntegratorStep(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2CompletedIntegratorStep() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2CompletedIntegratorStep!","page":"Developer Level API","title":"FMICore.fmi2CompletedIntegratorStep!","text":"Source: FMISpec2.0.2[p.85]: 3.2.2 Evaluation of Model Equations\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag completedIntegratorStepNotNeeded = false. If enterEventMode == fmi2True, the event mode must be entered If terminateSimulation == fmi2True, the simulation shall be terminated\n\n\n\n\n\nfmi2CompletedIntegratorStep!(c::FMU2Component,\n                                noSetFMUStatePriorToCurrentPoint::fmi2Boolean,\n                                enterEventMode::Ref{fmi2Boolean},\n                                terminateSimulation::Ref{fmi2Boolean})\n\nThis function must be called by the environment after every completed step of the integrator provided the capability flag completedIntegratorStepNotNeeded = false.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nnoSetFMUStatePriorToCurrentPoint::fmi2Boolean: Argument noSetFMUStatePriorToCurrentPoint = fmi2True if fmi2SetFMUState  will no longer be called for time instants prior to current time in this simulation run.\nenterEventMode::Ref{fmi2Boolean}: Argument enterEventMode points to the return value (fmi2Boolean) which signals to the environment if the FMU shall call fmi2EnterEventMode. fmi2Boolean is an alias type for Boolean data type.\nterminateSimulation::Ref{fmi2Boolean}: Argument terminateSimulation points to the return value (fmi2Boolean) which signals signal if the simulation shall be terminated. fmi2Boolean is an alias type for Boolean data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2CompletedIntegratorStep!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetDerivatives","page":"Developer Level API","title":"FMIImport.fmi2GetDerivatives","text":"fmi2GetDerivatives(c::FMU2Component)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nderivatives::Array{fmi2Real}: Returns an array of fmi2Real values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state\n\nvector.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\nfmi2GetDerivatives(fmu::FMU2)\n\nWrapper for fmi2GetDerivatives() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetDerivatives!","page":"Developer Level API","title":"FMICore.fmi2GetDerivatives!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nCompute state derivatives at the current time instant and for the current states.\n\n\n\n\n\nfmi2GetDerivatives!(c::FMU2Component,\n                   derivatives::AbstractArray{fmi2Real},\n                   nx::Csize_t)\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nderivatives::AbstractArray{fmi2Real}: Argument derivatives contains values of type fmi2Real which is a alias type for Real data type.derivatives is the AbstractArray which contains the Real values of the vector that represent the derivatives. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\nnx::Csize_t: Argument nx defines the length of vector derivatives and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\nfmi2GetDerivatives!(c::FMU2Component, derivatives::AbstractArray{fmi2Real})\n\nCompute state derivatives at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nderivatives::Array{fmi2Real}: Stores fmi2Real values representing the derivatives for the current states. The ordering of the elements of the derivatives vector is identical to the ordering of the state vector.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetDerivatives!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetEventIndicators","page":"Developer Level API","title":"FMIImport.fmi2GetEventIndicators","text":"fmi2GetEventIndicators(c::FMU2Component)\n\nReturns the event indicators of the FMU\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\neventIndicators::Array{fmi2Real}:The event indicators are returned as a vector represented by an array of \"fmi2Real\" values.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\nfmi2GetEventIndicators(fmu::FMU2)\n\nWrapper for fmi2GetEventIndicators() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetEventIndicators!","page":"Developer Level API","title":"FMICore.fmi2GetEventIndicators!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nCompute event indicators at the current time instant and for the current states.\n\n\n\n\n\nfmi2GetEventIndicators!(c::FMU2Component, eventIndicators::AbstractArray{fmi2Real}, ni::Csize_t)\n\nCompute event indicators at the current time instant and for the current states.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventIndicators::AbstractArray{fmi2Real}: Argument eventIndicators contains values of type fmi2Real which is a alias type for Real data type.eventIndicators is the AbstractArray which contains the Real values of the vector that represent the event indicators.\nni::Csize_t: Argument ni defines the length of vector eventIndicators and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\nfmi2GetEventIndicators!(c::FMU2Component, eventIndicators::AbstractArray{fmi2Real})\n\nReturns the event indicators of the FMU.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\neventIndicators::AbstractArray{fmi2Real}:The event indicators are in an AbstractArray represented by an array of \"fmi2Real\" values.\n\nReturns\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetContinuousStates","page":"Developer Level API","title":"FMIImport.fmi2GetContinuousStates","text":"fmi2GetContinuousStates(c::FMU2Component)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\nfmi2GetContinuousStates(fmu::FMU2)fmi2ins\n\nWrapper for fmi2GetContinuousStates() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetContinuousStates!","page":"Developer Level API","title":"FMICore.fmi2GetContinuousStates!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nReturn the new (continuous) state vector x.\n\n\n\n\n\nfmi2GetContinuousStates!(c::FMU2Component,\n                            x::AbstractArray{fmi2Real},\n                            nx::Csize_t)\n\nStores the new (continuous) state vector in x.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx::AbstractArray{fmi2Real}: Argument x contains values of type fmi2Real which is a alias type for Real data type.x is the AbstractArray which contains the Real values of the vector that represent the new state vector.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetNominalsOfContinuousStates","page":"Developer Level API","title":"FMIImport.fmi2GetNominalsOfContinuousStates","text":"fmi2GetNominalsOfContinuousStates(c::FMU2Component)\n\nReturn the new (continuous) state vector x\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nx::Array{fmi2Real}: Returns an array of fmi2Real values representing the new continuous state vector x.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetNominalsOfContinuousStates.\n\n\n\n\n\nfmi2GetNominalsOfContinuousStates(fmu::FMU2)\n\nWrapper for fmi2GetNominalsOfContinuousStates() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetNominalsOfContinuousStates!","page":"Developer Level API","title":"FMICore.fmi2GetNominalsOfContinuousStates!","text":"Source: FMISpec2.0.2[p.86]: 3.2.2 Evaluation of Model Equations\n\nReturn the nominal values of the continuous states.\n\n\n\n\n\nfmi2GetNominalsOfContinuousStates!(c::FMU2Component, x_nominal::AbstractArray{fmi2Real}, nx::Csize_t)\n\nStores the nominal values of the continuous states in x_nominal.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nx_nominal::AbstractArray{fmi2Real}: Argument x_nominal contains values of type fmi2Real which is a alias type for Real data type.x_nominal is the AbstractArray which contains the Real values of the vector that represent the nominal values of the continuous states.\nnx::Csize_t: Argument nx defines the length of vector x and is provided for checking purposes\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.83]: 3.2.2 Evaluation of Model Equations\n\nSee also fmi2GetEventIndicators!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMI-for-Co-Simulation","page":"Developer Level API","title":"FMI for Co-Simulation","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"This chapter defines the Functional Mock-up Interface (FMI) for the coupling of two or more simulation models in a Co-Simulation environment (FMI for Co-Simulation). Co-Simulation is a rather general approach to the simulation of coupled technical systems and coupled physical phenomena in engineering with focus on instationary (time-dependent) problems.","category":"page"},{"location":"fmi2_library/#Transfer-of-Input-/-Output-Values-and-Parameters","page":"Developer Level API","title":"Transfer of Input / Output Values and Parameters","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"In order to enable the slave to interpolate the continuous real inputs between communication steps, the derivatives of the inputs with respect to time can be provided. Also, higher derivatives can be set to allow higher order interpolation.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2GetRealOutputDerivatives","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2GetRealOutputDerivatives","page":"Developer Level API","title":"FMIImport.fmi2GetRealOutputDerivatives","text":"fmi2GetRealOutputDerivatives(c::FMU2Component, vr::fmi2ValueReferenceFormat, order::AbstractArray{fmi2Integer})\n\nSets the n-th time derivative of real input variables.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvr::Array{fmi2ValueReference}: Argument vr is an array of nvr value handels called \"ValueReference\" that t define the variables whose derivatives shall be set.\norder::Array{fmi2Integer}: Argument order is an array of fmi2Integer values witch specifys the corresponding order of derivative of the real input variable.\n\nReturns\n\nvalue::AbstactArray{fmi2Integer}: Return value is an array which represents a vector with the values of the derivatives.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\nFMISpec2.0.2[p.18]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.1 Transfer of Input / Output Values and Parameters\n\n\n\n\n\nfmi2GetRealOutputDerivatives(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetRealOutputDerivatives() in FMIImport/FMI2_int.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Computation","page":"Developer Level API","title":"Computation","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"The computation of time steps is controlled by the following function.","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2DoStep\nfmi2CancelStep","category":"page"},{"location":"fmi2_library/#FMICore.fmi2DoStep","page":"Developer Level API","title":"FMICore.fmi2DoStep","text":"Source: FMISpec2.0.2[p.104]: 4.2.2 Computation\n\nThe computation of a time step is started.\n\n\n\n\n\nfmi2DoStep(c::FMU2Component, \n                currentCommunicationPoint::fmi2Real, \n                communicationStepSize::fmi2Real, \n                noSetFMUStatePriorToCurrentPoint::fmi2Boolean)\n\nThe computation of a time step is started.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ncurrentCommunicationPoint::fmi2Real:  Argument currentCommunicationPoint contains a value of type fmi2Real which is a identifier for a variable value . currentCommunicationPoint defines the current communication point of the master.\ncommunicationStepSize::fmi2Real: Argument communicationStepSize contains a value of type fmi2Real which is a identifier for a variable value. communicationStepSize defines the communiction step size.\n\nnoSetFMUStatePriorToCurrentPoint::Bool = true: Argument noSetFMUStatePriorToCurrentPoint contains a value of type Boolean. If no argument is passed the default value true is used. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUState is no longer called for times before the currentCommunicationPoint in this simulation run Simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\nfmi2DoStep(c::FMU2Component, \n                communicationStepSize::Union{Real, Nothing} = nothing; \n                currentCommunicationPoint::Union{Real, Nothing} = nothing,\n                noSetFMUStatePriorToCurrentPoint::Bool = true)\n\nDoes one step in the CoSimulation FMU\n\nArguments\n\nC::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ncommunicationStepSize::Union{Real, Nothing} = nothing: Argument communicationStepSize contains a value of type Real or Nothing , if no argument is passed the default value nothing is used. communicationStepSize defines the communiction step size.\n\nKeywords\n\ncurrentCommunicationPoint::Union{Real, Nothing} = nothing: Argument currentCommunicationPoint contains a value of type Real or type Nothing. If no argument is passed the default value nothing is used. currentCommunicationPoint defines the current communication point of the master.\nnoSetFMUStatePriorToCurrentPoint::Bool = true: Argument noSetFMUStatePriorToCurrentPoint contains a value of type Boolean. If no argument is passed the default value true is used. noSetFMUStatePriorToCurrentPoint indicates whether fmi2SetFMUState is no longer called for times before the currentCommunicationPoint in this simulation run Simulation run.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\nfmi2DoStep(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2DoStep() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2CancelStep","page":"Developer Level API","title":"FMICore.fmi2CancelStep","text":"Source: FMISpec2.0.2[p.105]: 4.2.2 Computation\n\nCan be called if fmi2DoStep returned fmi2Pending in order to stop the current asynchronous execution.\n\n\n\n\n\nfmi2CancelStep(c::FMU2Component)\n\nCan be called if fmi2DoStep returned fmi2Pending in order to stop the current asynchronous execution.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.104]: 4.2.2 Computation\n\nSee also fmi2DoStep.\n\n\n\n\n\nfmi2CancelStep(fmu::FMU2)\n\nWrapper for fmi2CancelStep() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Retrieving-Status-Information-from-the-Slave","page":"Developer Level API","title":"Retrieving Status Information from the Slave","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"Status information is retrieved from the slave by the following functions:","category":"page"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2GetStatus!\nfmi2GetRealStatus!\nfmi2GetIntegerStatus!\nfmi2GetBooleanStatus!\nfmi2GetStringStatus!","category":"page"},{"location":"fmi2_library/#FMICore.fmi2GetStatus!","page":"Developer Level API","title":"FMICore.fmi2GetStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetStatus!(c::FMU2Component, \n                    s::fmi2StatusKind, \n                    value::Ref{fmi2Status})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Status}: The value argument points to a status flag that was requested.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetRealStatus!","page":"Developer Level API","title":"FMICore.fmi2GetRealStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetRealStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2Real})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Real}: Argument value points to the return value (fmi2Real) which was requested. fmi2Real is a alias type for Real data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetRealStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetIntegerStatus!","page":"Developer Level API","title":"FMICore.fmi2GetIntegerStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetIntegerStatus!(c::FMU2Component, \n                            s::fmi2StatusKind, \n                            value::Ref{fmi2Integer})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Integer}: Argument value points to the return value (fmi2Integer) which was requested. fmi2Integer is a alias type for Integer data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetIntegerStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetBooleanStatus!","page":"Developer Level API","title":"FMICore.fmi2GetBooleanStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetBooleanStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2Boolean})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue::Ref{fmi2Boolean}: Argument value points to the return value (fmi2Boolean) which was requested. fmi2Boolean is a alias type for Boolean data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetBooleanStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMICore.fmi2GetStringStatus!","page":"Developer Level API","title":"FMICore.fmi2GetStringStatus!","text":"Source: FMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\n\n\n\n\nfmi2GetStringStatus!(c::FMU2Component, \n                        s::fmi2StatusKind, \n                        value::Ref{fmi2String})\n\nInforms the master about the actual status of the simulation run. Which status information is to be returned is specified by the argument fmi2StatusKind.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\ns::fmi2StatusKind: Argument s defines which status information is to be returned. fmi2StatusKind is an enumeration that defines which status is inquired.\n\nThe following status information can be retrieved from a slave:\n\nfmi2DoStepStatus::fmi2Status: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers fmi2Pending if the computation is not finished. Otherwise the function returns the result of the asynchronously executed fmi2DoStep call.\nfmi2PendingStatus::fmi2String: Can be called when the fmi2DoStep function returned fmi2Pending. The function delivers a string which informs about the status of the currently running asynchronous fmi2DoStep computation\nfmi2LastSuccessfulTime:: fmi2Real: Returns the end time of the last successfully completed communication step. Can be called after fmi2DoStep(..) returned fmi2Discard.\nfmi2Terminated::fmi2Boolean: Returns fmi2True, if the slave wants to terminate the simulation. Can be called after fmi2DoStep(..) returned fmi2Discard. Use fmi2LastSuccessfulTime to determine the time instant at which the slave terminated.\nvalue:Ref{fmi2String}: Argument value points to the return value (fmi2String) which was requested. fmi2String is a alias type for String data type.\n\nReturns\n\nstatus::fmi2Status: Return status is an enumeration of type fmi2Status and indicates the success of the function call.\n\nMore detailed:\n\nfmi2OK: all well\nfmi2Warning: things are not quite right, but the computation can continue\nfmi2Discard: if the slave computed successfully only a subinterval of the communication step\nfmi2Error: the communication step could not be carried out at all\nfmi2Fatal: if an error occurred which corrupted the FMU irreparably\nfmi2Pending: this status is returned if the slave executes the function asynchronously\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\nFMISpec2.0.2[p.16]: 2.1.3 Status Returned by Functions\nFMISpec2.0.2[p.106]: 4.2.3 Retrieving Status Information from the Slave\n\nSee also fmi2GetStringStatus!.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#additional-functions","page":"Developer Level API","title":"additional  functions","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"These new functions, that are useful, but not part of the FMI-spec. (example: fmi2Load, fmi2SampleJacobian)","category":"page"},{"location":"fmi2_library/#Opening-and-closing-FMUs","page":"Developer Level API","title":"Opening and closing FMUs","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2Unzip\nfmi2Unload\nfmi2Load\nfmi2Reload","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2Unzip","page":"Developer Level API","title":"FMIImport.fmi2Unzip","text":"fmi2Unzip(pathToFMU::String; unpackPath=nothing, cleanup=true)\n\nCreate a copy of the .fmu file as a .zip folder and unzips it. Returns the paths to the zipped and unzipped folders.\n\nArguments\n\npathToFMU::String: The folder path to the .zip folder.\n\nKeywords\n\nunpackPath=nothing: Via optional argument unpackPath, a path to unpack the FMU can be specified (default: system temporary directory).\ncleanup=true: The cleanup option controls whether the temporary directory is automatically deleted when the process exits.\n\nReturns\n\nunzippedAbsPath::String: Contains the Path to the uzipped Folder.\nzipAbsPath::String: Contains the Path to the zipped Folder.\n\nSee also mktempdir.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2Unload","page":"Developer Level API","title":"FMIImport.fmi2Unload","text":"fmi2Unload(fmu::FMU2, cleanUp::Bool = true)\n\nUnload a FMU. Free the allocated memory, close the binaries and remove temporary zip and unziped FMU model description.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\ncleanUp::Bool= true: Defines if the file and directory should be deleted.\n\nKeywords\n\nsecure_pointers=true whether pointers to C-functions should be overwritten with dummies with Julia assertions, instead of pointing to dead memory (slower, but more user safe)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2Load","page":"Developer Level API","title":"FMIImport.fmi2Load","text":"fmi2Load(pathToFMU::String;\n            unpackPath=nothing, \n            type=nothing, \n            cleanup=true)\n\nSets the properties of the fmu by reading the modelDescription.xml. Retrieves all the pointers of binary functions.\n\nArguments\n\npathToFMU::String: The folder path to the .fmu file.\n\nKeywords\n\nunpackPath=nothing: Via optional argument unpackPath, a path to unpack the FMU can be specified (default: system temporary directory).\ntype=nothing: Defines whether a Co-Simulation or Model Exchange is present\ncleanup=true: The cleanup option controls whether the temporary directory is automatically deleted when the process exits.\n\nReturns\n\nReturns the instance of the FMU struct.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2Reload","page":"Developer Level API","title":"FMIImport.fmi2Reload","text":"fmi2Reload(fmu::FMU2)\n\nReloads the FMU-binary. This is useful, if the FMU does not support a clean reset implementation.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#Conversion-functions","page":"Developer Level API","title":"Conversion functions","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2StringToValueReference\nfmi2ModelVariablesForValueReference\nfmi2ValueReferenceToString\nfmi2GetSolutionState\nfmi2GetSolutionValue\nfmi2GetSolutionTime","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2StringToValueReference","page":"Developer Level API","title":"FMIImport.fmi2StringToValueReference","text":"fmi2StringToValueReference(md::fmi2ModelDescription, names::AbstractArray{String})\n\nReturns an array of ValueReferences coresponding to the variable names.\n\nArguments\n\nmd::fmi2ModelDescription: Argument md stores all static information related to an FMU. Especially, the FMU variables and their attributes such as name, unit, default initial value, etc..\nnames::AbstractArray{String}: Argument names contains a list of Strings. For each string (\"variable name\"), the corresponding value reference is searched in the given modelDescription.\n\nReturns\n\nvr:Array{fmi2ValueReference}: Return vr is an array of ValueReference coresponding to the variable names.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2StringToValueReference.\n\n\n\n\n\nfmi2StringToValueReference(md::fmi2ModelDescription, name::String)\n\nReturns the ValueReference or an array of ValueReferences coresponding to the variable names.\n\nArguments\n\nmd::fmi2ModelDescription: Argument md stores all static information related to an FMU. Especially, the FMU variables and their attributes such as name, unit, default initial value, etc..\nname::String: Argument names contains a String or a list of Strings. For each string (\"variable name\"), the corresponding value reference is searched in the given modelDescription.\n\nReturns\n\nreference::md.stringValueReferences: Return references is an array of ValueReference coresponding to the variable name.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2StringToValueReference\n\n\n\n\n\nfmi2StringToValueReference(fmu::FMU2, name::Union{String, AbstractArray{String}})\n\nReturns the ValueReference or an array of ValueReferences coresponding to the variable names.\n\nArguments\n\nfmu::FMU2:  Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nname::Union{String, AbstractArray{String}}: Argument names contains a Strings or AbstractArray{String}. For that, the corresponding value reference is searched in the given modelDescription.\n\nReturns\n\nFor input parameter name::Sting:\n\nreference::md.stringValueReferences: Return references is an array of ValueReference coresponding to the variable name.\n\nFor input parameter name::AbstractArray{String}\n\nar::Array{fmi2ScalarVariable}: Return ar is an array of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2StringToValueReference\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2ModelVariablesForValueReference","page":"Developer Level API","title":"FMIImport.fmi2ModelVariablesForValueReference","text":"fmi2ModelVariablesForValueReference(md::fmi2ModelDescription, vr::fmi2ValueReference)\n\nReturns the model variable(s) fitting the value reference.\n\nArguments\n\nmd::fmi2ModelDescription: Argument md stores all static information related to an FMU. Especially, the FMU variables and their attributes such as name, unit, default initial value, etc..\nvr::fmi2ValueReference: Argument vr contains a value of typefmi2ValueReference which are identifiers of a variable value of the model.\n\nReturns\n\nar::Array{fmi2ScalarVariable}: Return ar is an array of fmi2ScalarVariable containing the modelVariables with the identical fmi2ValueReference to the input variable vr.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.16]: 2.1.2 Platform Dependent Definitions\n\nSee also fmi2ModelVariablesForValueReference.\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2ValueReferenceToString","page":"Developer Level API","title":"FMIImport.fmi2ValueReferenceToString","text":"fmi2ValueReferenceToString(md::fmi2ModelDescription, reference::fmi2ValueReference)\n\nArguments\n\nmd::fmi2ModelDescription: Argument md stores all static information related to an FMU. Especially, the FMU variables and their attributes such as name, unit, default initial value, etc..\nreference::fmi2ValueReference: The argument references is a variable of the type ValueReference.\n\nReturn\n\nmd.stringValueReferences::Dict{String, fmi2ValueReference}: Returns a dictionary md.stringValueReferences that constructs a hash table with keys of type String and values of type fmi2ValueReference.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\nfmi2ValueReferenceToString(md::fmi2ModelDescription, reference::Int64)\n\nArguments\n\nmd::fmi2ModelDescription: Argument md stores all static information related to an FMU. Especially, the FMU variables and their attributes such as name, unit, default initial value, etc..\nreference::Int64: Argument references is a variable of the type Int64.\n\nReturn\n\nmd.stringValueReferences::Dict{String, fmi2ValueReference}: Returns a dictionary md.stringValueReferences that constructs a hash table with keys of type String and values of type fmi2ValueReference.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\nfmi2ValueReferenceToString(fmu::FMU2, reference::Union{fmi2ValueReference, Int64})\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nreference::Union{fmi2ValueReference, Int64}: Argument references of the type fmi2ValueReference or Int64.\n\nReturn\n\nmd.stringValueReferences::Dict{String, fmi2ValueReference}: Returns a dictionary md.stringValueReferences that constructs a hash table with keys of type String and values of type fmi2ValueReference.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetSolutionState","page":"Developer Level API","title":"FMIImport.fmi2GetSolutionState","text":"fmi2GetSolutionState(solution::FMU2Solution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the Solution state.\n\nArguments\n\nsolution::FMU2Solution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the spezific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf he length of the given referencees equals 1, each element u in the collection solution.states.u, it is selecting the element at the index represented by indices[1] and returns it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected elements. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one indice is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetSolutionValue","page":"Developer Level API","title":"FMIImport.fmi2GetSolutionValue","text":"fmi2GetSolutionValue(solution::FMU2Solution, vr::fmi2ValueReferenceFormat; isIndex::Bool=false)\n\nReturns the Solution values.\n\nArguments\n\nsolution::FMU2Solution: Struct contains information about the solution value, success, state and  events of a specific FMU.\nvr::fmi2ValueReferenceFormat: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nisIndex::Bool=false: Argument isIndex exists to check if vr ist the spezific solution element (\"index\") that equals the given fmi2ValueReferenceFormat\n\nReturn\n\nIf he length of the given referencees equals 1, each element u in the collection solution.values.saveval is selecting the element at the index represented by indices[1] and returns it.\n\nThus, the collect() function is taking the generator expression and returning an array of the selected elements. \n\nIf more than one reference is given, the same process takes place as before. The difference is that now more than one indice is accessed.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetSolutionTime","page":"Developer Level API","title":"FMIImport.fmi2GetSolutionTime","text":"fmi2GetSolutionTime(solution::FMU2Solution)\n\nReturns the Solution time.\n\nArguments\n\nsolution::FMU2Solution: Struct contains information about the solution value, success, state and  events of a specific FMU.\n\nReturn\n\nsolution.states.t::tType: solution.state is a struct ODESolution with attribute t. t is the time points corresponding to the saved values of the ODE solution.\nsolution.values.t::tType: solution.value is a struct ODESolution with attribute t.t the time points corresponding to the saved values of the ODE solution.\nIf no solution time is  found nothing is returned.\n\n#Source\n\nusing OrdinaryDiffEq: ODESolution  (SciML/SciMLBase.jl)\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2[p.22]: 2.1.2 Platform Dependent Definitions (fmi2TypesPlatform.h)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#External/Additional-functions","page":"Developer Level API","title":"External/Additional functions","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"fmi2GetJacobian\nfmi2GetJacobian!\nfmi2GetFullJacobian\nfmi2GetFullJacobian!\nfmi2GetStartValue\nfmi2GetUnit\nfmi2GetDeclaredType\nfmi2GetInitial\nfmi2GetSimpleTypeAttributeStruct","category":"page"},{"location":"fmi2_library/#FMIImport.fmi2GetJacobian","page":"Developer Level API","title":"FMIImport.fmi2GetJacobian","text":"fmi2GetJacobian(comp::FMU2Component,\n                    rdx::AbstractArray{fmi2ValueReference},\n                    rx::AbstractArray{fmi2ValueReference};\n                    steps::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nBuilds the jacobian over the FMU fmu for FMU value references rdx and rx, so that the function returns the jacobian ∂rdx / ∂rx.\n\nIf FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. For optimization, if the FMU's model description has the optional entry 'dependencies', only dependent variables are sampled/retrieved. This drastically boosts performance for systems with large variable count (like CFD).\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nrdx::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model.\nrx::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.\n\nKeywords\n\nsteps::Union{AbstractArray{fmi2Real}, Nothing} = nothing): If sampling is used, sampling step size can be set (for each direction individually) using optional argument steps.\n\nReturns\n\nmat::Array{fmi2Real}: Return mat contains the jacobian ∂rdx / ∂rx.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\nfmi2GetJacobian(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetJacobian() in FMIImport/FMI2_ext.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetJacobian!","page":"Developer Level API","title":"FMIImport.fmi2GetJacobian!","text":"fmi2GetJacobian!(jac::AbstractMatrix{fmi2Real},\n                      comp::FMU2Component,\n                      rdx::AbstractArray{fmi2ValueReference},\n                      rx::AbstractArray{fmi2ValueReference};\n                      steps::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nFills the jacobian over the FMU fmu for FMU value references rdx and rx, so that the function stores the jacobian ∂rdx / ∂rx in an AbstractMatrix jac.\n\nIf FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. For optimization, if the FMU's model description has the optional entry 'dependencies', only dependent variables are sampled/retrieved. This drastically boosts performance for systems with large variable count (like CFD).\n\nArguments\n\njac::AbstractMatrix{fmi2Real}: A matrix that will hold the computed Jacobian matrix.\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nrdx::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model.\nrx::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.\n\nKeywords\n\nsteps::Union{AbstractArray{fmi2Real}, Nothing} = nothing): Step size to be used for numerical differentiation. If nothing, a default value will be chosen automatically.\n\nReturns\n\nnothing\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\nfmi2GetJacobian!(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetJacobian!() in FMIImport/FMI2_ext.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetFullJacobian","page":"Developer Level API","title":"FMIImport.fmi2GetFullJacobian","text":"fmi2GetFullJacobian(comp::FMU2Component,\n                        rdx::AbstractArray{fmi2ValueReference},\n                        rx::AbstractArray{fmi2ValueReference};\n                        steps::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nBuilds the jacobian over the FMU fmu for FMU value references rdx and rx, so that the function returns the jacobian ∂rdx / ∂rx.\n\nIf FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. No performance optimization, for an optimized version use fmi2GetJacobian.\n\nArguments\n\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nrdx::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model.\nrx::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.\n\nKeywords\n\nsteps::Union{AbstractArray{fmi2Real}, Nothing} = nothing): If sampling is used, sampling step size can be set (for each direction individually) using optional argument steps.\n\nReturns\n\nmat::Array{fmi2Real}: Return mat contains the jacobian ∂rdx / ∂rx.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\nSee also fmi2GetFullJacobian!\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetFullJacobian!","page":"Developer Level API","title":"FMIImport.fmi2GetFullJacobian!","text":"fmi2GetFullJacobian!(jac::AbstractMatrix{fmi2Real},\n                          comp::FMU2Component,\n                          rdx::AbstractArray{fmi2ValueReference},\n                          rx::AbstractArray{fmi2ValueReference};\n                          steps::Union{AbstractArray{fmi2Real}, Nothing} = nothing)\n\nFills the jacobian over the FMU fmu for FMU value references rdx and rx, so that the function returns the jacobian ∂rdx / ∂rx.\n\nIf FMI built-in directional derivatives are supported, they are used. As fallback, directional derivatives will be sampled with central differences. No performance optimization, for an optimized version use fmi2GetJacobian!.\n\nArguments\n\njac::AbstractMatrix{fmi2Real}: Stores the the jacobian ∂rdx / ∂rx.\ncomp::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nrdx::AbstractArray{fmi2ValueReference}: Argument vUnknown_ref contains values of typefmi2ValueReference which are identifiers of a variable value of the model.\nrx::AbstractArray{fmi2ValueReference}: Argument vKnown_ref contains values of type fmi2ValueReference which are identifiers of a variable value of the model.\n\nKeywords\n\nsteps::Union{AbstractArray{fmi2Real}, Nothing} = nothing): Step size to be used for numerical differentiation.\n\nIf nothing, a default value will be chosen automatically.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetStartValue","page":"Developer Level API","title":"FMIImport.fmi2GetStartValue","text":"fmi2GetStartValue(md::fmi2ModelDescription, vrs::fmi2ValueReferenceFormat = md.valueReferences)\n\nReturns the start/default value for a given value reference.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nvrs::fmi2ValueReferenceFormat = md.valueReferences: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nstarts::Array{fmi2ValueReferenceFormat}: start/default value for a given value reference\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\nfmi2GetStartValue(fmu::FMU2, vrs::fmi2ValueReferenceFormat = fmu.modelDescription.valueReferences)\n\nReturns the start/default value for a given value reference.\n\nArguments\n\nfmu::FMU2: Mutable struct representing a FMU and all it instantiated instances in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat = fmu.modelDescription.valueReferences: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nstarts::fmi2ValueReferenceFormat: start/default value for a given value reference\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\nfmi2GetStartValue(c::FMU2Component, vrs::fmi2ValueReferenceFormat = c.fmu.modelDescription.valueReferences)\n\nReturns the start/default value for a given value reference.\n\nArguments\n\nc::FMU2Component: Mutable struct represents an instantiated instance of an FMU in the FMI 2.0.2 Standard.\nvrs::fmi2ValueReferenceFormat = c.fmu.modelDescription.valueReferences: wildcards for how a user can pass a fmi[X]ValueReference (default = md.valueReferences)\n\nMore detailed: fmi2ValueReferenceFormat = Union{Nothing, String, Array{String,1}, fmi2ValueReference, Array{fmi2ValueReference,1}, Int64, Array{Int64,1}, Symbol}\n\nReturns\n\nstarts::fmi2ValueReferenceFormat: start/default value for a given value reference\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\nfmi2GetStartValue(mv::fmi2ScalarVariable)\n\nReturns the start/default value for a given value reference.\n\nArguments\n\nmv::fmi2ScalarVariable: The “ModelVariables” element consists of an ordered set of “ScalarVariable” elements. A “ScalarVariable” represents a variable of primitive type, like a real or integer variable.\n\nReturns\n\nmv._Real.start: start/default value for a given ScalarVariable. In this case representing a variable of primitive type Real.\nmv._Integer.start: start/default value for a given ScalarVariable. In this case representing a variable of primitive type Integer.\nmv._Boolean.start: start/default value for a given ScalarVariable. In this case representing a variable of primitive type Boolean.\nmv._String.start: start/default value for a given ScalarVariable. In this case representing a variable of primitive type String.\nmv._Enumeration.start: start/default value for a given ScalarVariable. In this case representing a variable of primitive type Enumeration.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\nfmi2GetStartValue(fmu::FMU2, args...; kwargs...)\n\nWrapper for fmi2GetStartValue() in FMIImport/FMI2_c.jl\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetUnit","page":"Developer Level API","title":"FMIImport.fmi2GetUnit","text":"fmi2GetUnit(mv::fmi2ScalarVariable)\n\nReturns the unit entry (a string) of the corresponding model variable.\n\nArguments\n\nfmi2GetStartValue(mv::fmi2ScalarVariable): The “ModelVariables” element consists of an ordered set of “ScalarVariable” elements. A “ScalarVariable” represents a variable of primitive type, like a real or integer variable.\n\nReturns\n\nmv.Real.unit: Returns the unit entry of the corresponding ScalarVariable representing a variable of the primitive type Real. Otherwise nothing is returned.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\nfmi2GetUnit(st::fmi2SimpleType)\n\nReturns the unit entry (a string) of the corresponding simple type st if it has the  attribute Real and nothing otherwise.\n\nSource\n\nFMISpec2.0.3 Link: https://fmi-standard.org/\nFMISpec2.0.3: 2.2.3 Definition of Types (TypeDefinitions)\n\n\n\n\n\nfmi2GetUnit(md::fmi2ModelDescription, mv::fmi2ScalarVariable)\n\nReturns the unit of the corresponding model variable mv as a fmi2Unit if it is defined in md.unitDefinitions.\n\nArguments\n\nmd::fmi2ModelDescription: Struct which provides the static information of ModelVariables.\nmv::fmi2ScalarVariable: The “ModelVariables” element consists of an ordered set of “ScalarVariable” elements. A “ScalarVariable” represents a variable of primitive type, like a real or integer variable.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#FMIImport.fmi2GetInitial","page":"Developer Level API","title":"FMIImport.fmi2GetInitial","text":"fmi2GetInitial(mv::fmi2ScalarVariable)\n\nReturns the inital entry of the corresponding model variable.\n\nArguments\n\nfmi2GetStartValue(mv::fmi2ScalarVariable): The “ModelVariables” element consists of an ordered set of “ScalarVariable” elements. A “ScalarVariable” represents a variable of primitive type, like a real or integer variable.\n\nReturns\n\nmv.Real.unit: Returns the inital entry of the corresponding ScalarVariable representing a variable of the primitive type Real. Otherwise nothing is returned.\n\nSource\n\nFMISpec2.0.2 Link: https://fmi-standard.org/\nFMISpec2.0.2: 2.2.7  Definition of Model Variables (ModelVariables)\n\n\n\n\n\n","category":"function"},{"location":"fmi2_library/#All-functions","page":"Developer Level API","title":"All functions","text":"","category":"section"},{"location":"fmi2_library/","page":"Developer Level API","title":"Developer Level API","text":"","category":"page"},{"location":"examples/multiprocessing/#Multiprocessing","page":"Multiprocessing","title":"Multiprocessing","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Tutorial by Jonas Wilfert, Tobias Thummerer","category":"page"},{"location":"examples/multiprocessing/#License","page":"Multiprocessing","title":"License","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"# Copyright (c) 2021 Tobias Thummerer, Lars Mikelsons, Josef Kircher, Johannes Stoljar, Jonas Wilfert\n# Licensed under the MIT license. \n# See LICENSE (https://github.com/thummeto/FMI.jl/blob/main/LICENSE) file in the project root for details.","category":"page"},{"location":"examples/multiprocessing/#Motivation","page":"Multiprocessing","title":"Motivation","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This Julia Package FMI.jl is motivated by the use of simulation models in Julia. Here the FMI specification is implemented. FMI (Functional Mock-up Interface) is a free standard (fmi-standard.org) that defines a container and an interface to exchange dynamic models using a combination of XML files, binaries and C code zipped into a single file. The user can thus use simulation models in the form of an FMU (Functional Mock-up Units). Besides loading the FMU, the user can also set values for parameters and states and simulate the FMU both as co-simulation and model exchange simulation.","category":"page"},{"location":"examples/multiprocessing/#Introduction-to-the-example","page":"Multiprocessing","title":"Introduction to the example","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"This example shows how to parallelize the computation of an FMU in FMI.jl. We can compute a batch of FMU-evaluations in parallel with different initial settings. Parallelization can be achieved using multithreading or using multiprocessing. This example shows multiprocessing, check multithreading.ipynb for multithreading. Advantage of multithreading is a lower communication overhead as well as lower RAM usage. However in some cases multiprocessing can be faster as the garbage collector is not shared.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The model used is a one-dimensional spring pendulum with friction. The object-orientated structure of the SpringFrictionPendulum1D can be seen in the following graphic.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"(Image: svg)  ","category":"page"},{"location":"examples/multiprocessing/#Target-group","page":"Multiprocessing","title":"Target group","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"The example is primarily intended for users who work in the field of simulations. The example wants to show how simple it is to use FMUs in Julia.","category":"page"},{"location":"examples/multiprocessing/#Other-formats","page":"Multiprocessing","title":"Other formats","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Besides, this Jupyter Notebook there is also a Julia file with the same name, which contains only the code cells and for the documentation there is a Markdown file corresponding to the notebook.  ","category":"page"},{"location":"examples/multiprocessing/#Getting-started","page":"Multiprocessing","title":"Getting started","text":"","category":"section"},{"location":"examples/multiprocessing/#Installation-prerequisites","page":"Multiprocessing","title":"Installation prerequisites","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":" Description Command Alternative\n1. Enter Package Manager via ] \n2. Install FMI via add FMI add \" https://github.com/ThummeTo/FMI.jl \"\n3. Install FMIZoo via add FMIZoo add \" https://github.com/ThummeTo/FMIZoo.jl \"\n4. Install FMICore via add FMICore add \" https://github.com/ThummeTo/FMICore.jl \"\n5. Install BenchmarkTools via add BenchmarkTools ","category":"page"},{"location":"examples/multiprocessing/#Code-section","page":"Multiprocessing","title":"Code section","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Adding your desired amount of processes:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"using Distributed\nn_procs = 2\naddprocs(n_procs; exeflags=`--project=$(Base.active_project()) --threads=auto`, restrict=false)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"2-element Vector{Int64}:\n 2\n 3","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To run the example, the previously installed packages must be included. ","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"# imports\n@everywhere using FMI\n@everywhere using FMIZoo\n@everywhere using BenchmarkTools","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Checking that we workers have been correctly initialized:","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"workers()\n\n@everywhere println(\"Hello World!\")\n\n# The following lines can be uncommented for more advanced informations about the subprocesses\n# @everywhere println(pwd())\n# @everywhere println(Base.active_project())\n# @everywhere println(gethostname())\n# @everywhere println(VERSION)\n# @everywhere println(Threads.nthreads())","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Hello World!\n      From worker 2:\tHello World!\n      From worker 3:\tHello World!","category":"page"},{"location":"examples/multiprocessing/#Simulation-setup","page":"Multiprocessing","title":"Simulation setup","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Next, the batch size and input values are defined.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"\n# Best if batchSize is a multiple of the threads/cores\nbatchSize = 16\n\n# Define an array of arrays randomly\ninput_values = collect(collect.(eachrow(rand(batchSize,2))))","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"16-element Vector{Vector{Float64}}:\n [0.24011468373666867, 0.7476887069835392]\n [0.9182054419854113, 0.8611883244502313]\n [0.13576312602924356, 0.03635909742573018]\n [0.5844044679911422, 0.30322265426226014]\n [0.6173556391757996, 0.30239779884468987]\n [0.9852596407976792, 0.4095603393542945]\n [0.21649118803941358, 0.5146432279844775]\n [0.7490499633802343, 0.0716654256001098]\n [0.3590856694660114, 0.05672402159732637]\n [0.7647518243662416, 0.5117982902982106]\n [0.029448071263047826, 0.7106659745412811]\n [0.4002779912293556, 0.9887342924210344]\n [0.6788957963556156, 0.35324180494620394]\n [0.1143809978848892, 0.6136098722124553]\n [0.15767044825835363, 0.7218309989369175]\n [0.9567352034217161, 0.533707537347975]","category":"page"},{"location":"examples/multiprocessing/#Shared-Module","page":"Multiprocessing","title":"Shared Module","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"For Distributed we need to embed the FMU into its own module. This prevents Distributed from trying to serialize and send the FMU over the network, as this can cause issues. This module needs to be made available on all processes using @everywhere.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere module SharedModule\n    using FMIZoo\n    using FMI\n\n    t_start = 0.0\n    t_step = 0.1\n    t_stop = 10.0\n    tspan = (t_start, t_stop)\n    tData = collect(t_start:t_step:t_stop)\n\n    model_fmu = FMIZoo.fmiLoad(\"SpringPendulum1D\", \"Dymola\", \"2022x\")\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"We define a helper function to calculate the FMU and combine it into an Matrix.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere function runCalcFormatted(fmu, x0, recordValues=[\"mass.s\", \"mass.v\"])\n    data = fmiSimulateME(fmu, SharedModule.tspan; recordValues=recordValues, saveat=SharedModule.tData, x0=x0, showProgress=false, dtmax=1e-4)\n    return reduce(hcat, data.states.u)\nend","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Running a single evaluation is pretty quick, therefore the speed can be better tested with BenchmarkTools.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@benchmark data = runCalcFormatted(SharedModule.model_fmu, rand(2))","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mUsing arrays or dicts to store parameters of different types can hurt performance.\n\u001b[33m\u001b[1m│ \u001b[22m\u001b[39mConsider using tuples instead.\n\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ SciMLBase ~/.julia/packages/SciMLBase/wvDeR/src/performance_warnings.jl:32\u001b[39m\n\n\n\n\n\nBenchmarkTools.Trial: 3 samples with 1 evaluation.\n Range \u001b[90m(\u001b[39m\u001b[36m\u001b[1mmin\u001b[22m\u001b[39m … \u001b[35mmax\u001b[39m\u001b[90m):  \u001b[39m\u001b[36m\u001b[1m1.706 s\u001b[22m\u001b[39m … \u001b[35m  1.756 s\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmin … max\u001b[90m): \u001b[39m4.52% … 4.40%\n Time  \u001b[90m(\u001b[39m\u001b[34m\u001b[1mmedian\u001b[22m\u001b[39m\u001b[90m):     \u001b[39m\u001b[34m\u001b[1m1.722 s              \u001b[22m\u001b[39m\u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmedian\u001b[90m):    \u001b[39m4.49%\n Time  \u001b[90m(\u001b[39m\u001b[32m\u001b[1mmean\u001b[22m\u001b[39m ± \u001b[32mσ\u001b[39m\u001b[90m):   \u001b[39m\u001b[32m\u001b[1m1.728 s\u001b[22m\u001b[39m ± \u001b[32m26.031 ms\u001b[39m  \u001b[90m┊\u001b[39m GC \u001b[90m(\u001b[39mmean ± σ\u001b[90m):  \u001b[39m4.47% ± 0.06%\n\n  \u001b[34m█\u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[32m \u001b[39m\u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m \u001b[39m█\u001b[39m \u001b[39m \n  \u001b[34m█\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[32m▁\u001b[39m\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m▁\u001b[39m█\u001b[39m \u001b[39m▁\n  1.71 s\u001b[90m         Histogram: frequency by time\u001b[39m        1.76 s \u001b[0m\u001b[1m<\u001b[22m\n\n Memory estimate\u001b[90m: \u001b[39m\u001b[33m467.05 MiB\u001b[39m, allocs estimate\u001b[90m: \u001b[39m\u001b[33m12001288\u001b[39m.","category":"page"},{"location":"examples/multiprocessing/#Single-Threaded-Batch-Execution","page":"Multiprocessing","title":"Single Threaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"To compute a batch we can collect multiple evaluations. In a single threaded context we can use the same FMU for every call.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Single Threaded\")\n@benchmark collect(runCalcFormatted(SharedModule.model_fmu, i) for i in input_values)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Single Threaded\n\n\n\n\n\nBenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took \u001b[34m27.307 s\u001b[39m (4.73% GC) to evaluate,\n with a memory estimate of \u001b[33m7.30 GiB\u001b[39m, over \u001b[33m192020596\u001b[39m allocations.","category":"page"},{"location":"examples/multiprocessing/#Multithreaded-Batch-Execution","page":"Multiprocessing","title":"Multithreaded Batch Execution","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In a multithreaded context we have to provide each thread it's own fmu, as they are not thread safe. To spread the execution of a function to multiple processes, the function pmap can be used.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"println(\"Multi Threaded\")\n@benchmark pmap(i -> runCalcFormatted(SharedModule.model_fmu, i), input_values)","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"Multi Threaded\n      From worker 3:\t\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mUsing arrays or dicts to store parameters of different types can hurt performance.\n      From worker 3:\t\u001b[33m\u001b[1m│ \u001b[22m\u001b[39mConsider using tuples instead.\n      From worker 3:\t\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ SciMLBase ~/.julia/packages/SciMLBase/wvDeR/src/performance_warnings.jl:32\u001b[39m\n      From worker 2:\t\u001b[33m\u001b[1m┌ \u001b[22m\u001b[39m\u001b[33m\u001b[1mWarning: \u001b[22m\u001b[39mUsing arrays or dicts to store parameters of different types can hurt performance.\n      From worker 2:\t\u001b[33m\u001b[1m│ \u001b[22m\u001b[39mConsider using tuples instead.\n      From worker 2:\t\u001b[33m\u001b[1m└ \u001b[22m\u001b[39m\u001b[90m@ SciMLBase ~/.julia/packages/SciMLBase/wvDeR/src/performance_warnings.jl:32\u001b[39m\n\n\n\n\n\nBenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took \u001b[34m14.933 s\u001b[39m (0.00% GC) to evaluate,\n with a memory estimate of \u001b[33m86.77 KiB\u001b[39m, over \u001b[33m1481\u001b[39m allocations.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"As you can see, there is a significant speed-up in the median execution time. But: The speed-up is often much smaller than n_procs (or the number of physical cores of your CPU), this has different reasons. For a rule of thumb, the speed-up should be around n/2 on a n-core-processor with n Julia processes.","category":"page"},{"location":"examples/multiprocessing/#Unload-FMU","page":"Multiprocessing","title":"Unload FMU","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"After calculating the data, the FMU is unloaded and all unpacked data on disc is removed.","category":"page"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"@everywhere fmiUnload(SharedModule.model_fmu)","category":"page"},{"location":"examples/multiprocessing/#Summary","page":"Multiprocessing","title":"Summary","text":"","category":"section"},{"location":"examples/multiprocessing/","page":"Multiprocessing","title":"Multiprocessing","text":"In this tutorial it is shown how multi processing with Distributed.jl can be used to improve the performance for calculating a Batch of FMUs.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo)","category":"page"},{"location":"#FMI.jl","page":"Introduction","title":"FMI.jl","text":"","category":"section"},{"location":"#What-is-FMI.jl?","page":"Introduction","title":"What is FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is a free-to-use software library for the Julia programming language which integrates the Functional Mock-Up Interface (fmi-standard.org): load or create, parameterize, differentiate, simulate and plot FMUs seamlessly inside the Julia programming language!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Dev Docs)  (Image: Test (latest)) (Image: Test (LTS)) (Image: FMI2 Cross Checks (latest)) (Image: Examples (latest)) (Image: Build Docs) (Image: Run PkgEval) (Image: Coverage) (Image: ColPrac: Contributor's Guide on Collaborative Practices for Community Packages) (Image: FMI Downloads).","category":"page"},{"location":"#How-can-I-use-FMI.jl?","page":"Introduction","title":"How can I use FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"1. Open a Julia-REPL, switch to package mode using ], activate your preferred environment.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"2. Install FMI.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@v1) pkg> add FMI","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"3. If you want to check that everything works correctly, you can run the tests bundled with FMI.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(@v1) pkg> test FMI","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"4. Have a look inside the examples folder in the examples branch or the examples section of the documentation. All examples are available as Julia-Script (.jl), Jupyter-Notebook (.ipynb) and Markdown (.md).","category":"page"},{"location":"#How-can-I-simulate-a-FMU-and-plot-values?","page":"Introduction","title":"How can I simulate a FMU and plot values?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"using FMI, Plots\n\n# load and instantiate a FMU\nfmu = fmiLoad(pathToFMU) \n\n# simulate from t=0.0s until t=10.0s and record the FMU variable named \"mass.s\"\nsimData = fmiSimulate(fmu, (0.0, 10.0); recordValues=[\"mass.s\"])\n\n# plot it!\nplot(simData)\n\n# free memory\nfmiUnload(myFMU)","category":"page"},{"location":"#What-is-currently-supported-in-FMI.jl?","page":"Introduction","title":"What is currently supported in FMI.jl?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"importing the full FMI 2.0.3 and FMI 3.0.0 command set, including optional specials like fmi2GetState, fmi2SetState and fmi2GetDirectionalDerivatives\nparameterization, simulation & plotting of CS- and ME-FMUs\nevent-handling for imported discontinuous ME-FMUs","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":" FMI2.0.3  FMI3.0  SSP1.0 \n Import Export Import Export Import Export\nCS ✔️✔️ 🚧 ✔️ 📅 📅 📅\nME (continuous) ✔️✔️ ✔️✔️ 🚧 📅 📅 📅\nME (discontinuous) ✔️✔️ ✔️✔️ 🚧 📅 📅 📅\nSE 🚫 🚫 🚧 📅 🚫 🚫\nExplicit solvers ✔️✔️ ✔️✔️ ✔️ 📅 📅 📅\nImplicit solvers (autodiff=false) ✔️✔️ 🚧 ✔️ 📅 📅 📅\nImplicit solvers (autodiff=true) ✔️✔️ 🚧 🚧 📅 📅 📅\nget/setState ✔️✔️ 📅 ✔️ 📅 🚫 🚫\ngetDirectionalDerivatives ✔️✔️ 📅 ✔️ 📅 🚫 🚫\ngetAdjointDerivatives 🚫 🚫 ✔️ 📅 🚫 🚫\nFMI Cross Checks ✔️✔️ 📅 📅 📅 🚫 🚫","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"✔️✔️ supported & tested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"✔️  beta supported (implemented), but untested","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"🚧 work in progress","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"📅  planned","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"🚫  not supported by the corresponding FMI standard (not applicable)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"❌  not planned","category":"page"},{"location":"#What-FMI.jl-Library-to-use?","page":"Introduction","title":"What FMI.jl-Library to use?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: FMI.jl Logo) To keep dependencies nice and clean, the original package FMI.jl had been split into new packages:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl: High level loading, manipulating, saving or building entire FMUs from scratch\nFMIImport.jl: Importing FMUs into Julia\nFMIExport.jl: Exporting stand-alone FMUs from Julia Code\nFMICore.jl: C-code wrapper for the FMI-standard\nFMIBuild.jl: Compiler/Compilation dependencies for FMIExport.jl\nFMIFlux.jl: Machine Learning with FMUs (differentiation over FMUs)\nFMIZoo.jl: A collection of testing and example FMUs","category":"page"},{"location":"#What-Platforms-are-supported?","page":"Introduction","title":"What Platforms are supported?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"FMI.jl is tested (and testing) under Julia Versions 1.6 LTS (64-bit) and latest (64-bit) on Windows latest (64-bit) and Ubuntu latest (64-bit). Mac and Julia (32-bit) should work, but untested. For the best performance, we recommend using Julia >= 1.7.","category":"page"},{"location":"#How-to-cite?","page":"Introduction","title":"How to cite?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Lars Mikelsons and Josef Kircher. 2021. NeuralFMU: towards structural integration of FMUs into neural networks. Martin Sjölund, Lena Buffoni, Adrian Pop and Lennart Ochel (Ed.). Proceedings of 14th Modelica Conference 2021, Linköping, Sweden, September 20-24, 2021. Linköping University Electronic Press, Linköping (Linköping Electronic Conference Proceedings ; 181), 297-306. DOI: 10.3384/ecp21181297","category":"page"},{"location":"#Related-publications?","page":"Introduction","title":"Related publications?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Johannes Stoljar and Lars Mikelsons. 2022. NeuralFMU: presenting a workflow for integrating hybrid NeuralODEs into real-world applications. Electronics 11, 19, 3202. DOI: 10.3390/electronics11193202","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Tobias Thummerer, Johannes Tintenherr, Lars Mikelsons. 2021 Hybrid modeling of the human cardiovascular system using NeuralFMUs Journal of Physics: Conference Series 2090, 1, 012155. DOI: 10.1088/1742-6596/2090/1/012155","category":"page"},{"location":"#Notes-for-contributors","page":"Introduction","title":"Notes for contributors","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Contributors are welcome. Before contributing, please read, understand and follow the Contributor's Guide on Collaborative Practices for Community Packages.  During development of new implementations or optimizations on exisitng code, one will have to make design decissions that influence the library performance and usability. The following priorization should be the basis for decision-making:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"#1 Compliance with standard: It is the highest priority to be compliant with the FMI standard (fmi-standard.org). Identifiers described in the standard must be used. Topologies should follow the specification as far as the possibilities of the Julia programming language allows.\n#2 Performance: Because FMI.jl is a simulation tool, performance is very important. This applies to the efficient use of CPU and GPU, but also the conscientious use of RAM and disc space.\n#3 Usability: The library should be as usable as possible, as long as being fully compliant with the FMI standard.","category":"page"},{"location":"#Interested-in-Hybrid-Modelling-in-Julia-using-FMUs?","page":"Introduction","title":"Interested in Hybrid Modelling in Julia using FMUs?","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See FMIFlux.jl.","category":"page"}]
}
